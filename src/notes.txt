Основной объект в исчислении конструкций -- это термы.

Синтаксис термов над множеством переменных X 
и множеством типов Sorts={Prop} U (U_{i ∈ N} {Type_i}) 
задается следующей БНФ 
term ::= x | s | (fun (x : term) => term) | (term term) | Π (x:term), term, 
где s ∈ Sorts, x ∈ V.

Каждый терм, построенный согласно описанной выше БНФ, 
ставится в соответствии типу (или имеет тип), который также является термом.


Пусть термы, которые обозначены через переменные x_1, ..., x_n, 
имеют тип A_1, ..., A_n. 
Множество Γ = [x_1:A_1, x_2:A_2, ..., x_n: A_n] 
называется контекстом.

Запись t{x/u} обозначает терм t, в котором 
свободная переменная x заменена на терм u, 
который имеет такой же тип.
Cуждения о типе -- это запись:
Γ |- t: A, 
где 
    Γ -- это контекст, 
    t -- это терм, который имеет тип A 
    (который называется заключением).

Эта запись обозначает: 
"в предположении, 
что переменные x_i имеют тип A_i, терм t имеет тип A"

Формулы исчисления конструкций -- это суждения о типе.
Правила вывода исчисления конструкций:
<Правила вывода>
Согласно правилам вывода 
строятся суждения от том, какого типа терм.

"(fun (x : term_1) => term_2)" 
обозначает отображение с аргументом x типа term_1, 
возвращающее для значения v этого аргумента 
значение выражения term_2 на v (взял со слайдов)
"(term_1 term_2)" обозначает результат 
применения отображения,
записанного как term_1, к аргументу, 
записанному как term_2 (взял со слайдов)
"Π (x:term_1), term_2" 
обозначает семейство типов (термов) 
параметризованных термом x. (со слайдов из вики)
"x" -- терм с именем x, имеющий тип согласно контексту
"s" -- сорт, тип которого 
определяется согласно правилам вывода.

Через FV(M) обозначим множество 
свободных переменных в терме M.
Запись "A -> B" означает Πx:A.B, где x ∉ FV(B).

Правило β-редукции
(fun x:A => M ) N  ->_β M{x/N} 
(можно ли сказать что терм слева и 
справа будем считать идентичными?)


Исчисление индуктивных конструкций.
Пусть Names и Constr множество имен, 

Индуктивный тип -- 
это пара
(I parameters: Ar, constructors), где
I ∈ Names -- имя индуктивного типа,
parameters -- это параметры p_1:P_1, ..., p_n:P_n,
Ar -- это тип этого индуктивного типа,
constructors -- множество термов или кострукторов, 
которые имеют имя constr_i ∈ Constr и тип с_i:
constructors = {constr_i: с_i}.

Ar строится следующим образом
Π(y1 : B1)..(yp : Bp),s, где s ∈ Sorts.
с_i строится следующим образом
Π(x_i1 : A_i1)..(y_ik : A_ik), I parameters

Тип c_i коструктора constr_i 
имеет следующие ограничения
1. Если c_i не является типом Prop, 
тогда каждый тип A_ij 
имеет тип c_i 
или имеет тип Prop.
2. если c_i является типом Prop,
!проблема!

3. 
выполнение условия "позитивности" для типов A_ij 
относительно появления самого индуктивного типа I
в одном из следующих случаев:
-- I не появляется в A_ij 
-- A_ij = I t_1 ... t_p, I ∉ t_k
-- A_i = Πz:B_1, B_2 
(I ∉ B_1, для I выполнено условие позитивности в B_2)
-- A_i = J t_1 ... t_q, где J другой индуктивный тип 
с параметрами X_1, ... X_r, 
условие позитивности должно выполнятся
в J{X_1/t_1}...{X_r/t_r}. I ∉ t_k, где r < k ≤ q.

Введение понятия индуктивного типа позволяет 
внести дополнительно две функциональные конструкции.

Первая конструкция -- это сопоставление по шаблону
(pattern-matching)
Синтаксис сопоставления по шаблону 
match t as x in I y1 ...yp return P 
with 
с_1 x1 ...xn => f_1
...
с_n x1 ...xn => f_n
end : P[t1/y1,...,tp/yp,t/x]

