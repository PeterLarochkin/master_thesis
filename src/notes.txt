
Исчисление кострукций.
Исчисление конструкций (оно же pure type system) лежит 
в основе исчисления индуктивных конструкций.
Основной объект в исчислении конструкций -- это термы.
Синтаксис.
Синтаксис термов над множеством переменных X 
и множеством типов Sorts={Prop} U (U_{i ∈ N} {Type_i}) 
задается следующей БНФ 
term ::= 
x | 
s | 
(fun (x : term) => term) | 
(term term) | 
Π (x:term), term, 
где s ∈ Sorts, x ∈ V.

Каждый терм, построенный согласно описанной выше БНФ, 
ставится в соответствии типу или имеют тип, который также является термом.
Пусть термы, которые обозначены через переменные x_1, ..., x_n, 
имеют тип A_1, ..., A_n. 
Множество Γ = [x_1:A_1, x_2:A_2, ..., x_n: A_n] 
называется контекстом.

Запись t{x/u} обозначает терм t, в котором 
свободная переменная x заменена на терм u, 
который имеет такой же тип.
Формулами исчисления конструкций являются суждения о типе, 
которые записываются следующим образом:
Γ |- t: A, 
где 
    Γ -- это контекст, 
    t -- это терм, который имеет тип A 
    (который называется заключением).

Эта запись обозначает: 
"в предположении, 
что переменные x_i имеют типа A_i, терм t имеет тип A" 
Правила вывода исчисления конструкций:
<Правила вывода>

Согласно правилам вывода, 
можно строить суждения от том, какой тип имеет терм.
Это и есть семантика(?).


Исчисление индуктивных конструкций.
Определим понятие индуктивного типа.
Пусть Names и Constr множество имен, 

Индуктивный тип -- 
это пара следующего вида:

(I parameters: Ar, constructors), где
I ∈ Names -- имя индуктивного типа,
parameters -- это параметры p_1:P_1, ..., p_n:P_n,
Ar -- это тип этого индуктивного типа,
constructors -- множество термов или кострукторов, 
которые имеют имя constr_i ∈ Constr и тип с_i:
constructors = {constr_i: A_i}.

(Вообще говоря, кажется как будто можно построить 
суждения о типе согласно этим (ниже) правилам.)

Ar строится согласно синтаксису
Π(y1 : B1)..(yp : Bp),s, где s ∈ Sorts.
с_i строится согласно синтаксису
Π(x_i1 : A_i1)..(y_ik : A_ik), I parameters

Тип c_i коструктора constr_i 
имеет следующие ограничения
1. Если c_i не является типом Prop, 
тогда каждый тип A_ij 
имеет тип c_i 
или имеет тип Prop.
2. если c_i является типом Prop,
!проблема!

3. 
выполнение условия "позитивности" для типов A_ij 
относительно появления самого индуктивного типа I
в одном из следующих случаев:
-- I не появляется в A_ij 
-- A_ij = I t_1 ... t_p, I ∉ t_k
-- A_i = Πz:B_1, B_2 
(I ∉ B_1, для I выполнено условие позитивности в B_2)
-- A_i = J t_1 ... t_q, где J другой индуктивный тип 
с параметрами X_1, ... X_r, 
условие позитивности должно выполнятся
в J{X_1/t_1...X_r/t_r}. I ∉ t_k, где r < k ≤ q.

Таким обрвзо