(* 
ORIGINAL
G -> 2^G
[[phi;psi]] : G -> FinSetG


*)

(* 
Mine
G is ordered set of Type [Type, ...], which need to constuct.
[[phi;psi]] = λg:G. {h | h \in G и \exists u : u \in [[phi]](g) и h \in [[psi]](u) } s: G -> G
*)


Require Import Nat.
Ltac print_numgoals := let n := numgoals in idtac "# of goals:" n.
(* Goal forall P Q: Prop, P \/ Q -> Q \/ P.
  intros. destruct H.
  print_numgoals. *)

Definition P (n:nat) := True.




Ltac two_auto := [> unfold P; auto | unfold P; auto].
Goal P 1 /\ P 2.
split.
(* Using the all selector for getting several focused goals *)
all:two_auto.
(* all, 1-2 it's top level selector *)
Qed.

(* 
"Unformal": The expressions ltac_expri are evaluated to vi, for i = 1, ..., n and all have to be tactics. 
The vi is applied to the i-th goal, for i = 1, ..., n. 
It fails if the number of focused goals is not exactly n. 
"Formal": [[ '[>' phi_1 '|' ... '|' phi_i '|' ... '|' phi_n ']' ]] = λg:G. if length(G) == n then {g_i ∈ G| ϕ g_i} else "fail".
*)




Goal P 1 /\ P 2.
(* Using the all selector for getting several focused goals *)
split; [ unfold P; auto | unfold P; auto].
(* products from split to it's top level selector *)
Qed.
(* 
"Maybe removed"
"Unformal": This variant of local tactic application is paired with a sequence. 
In this variant, there must be as many ltac_expri as goals generated by the application of 
ltac_expr0 to each of the individual goals independently.
All the above variants work in this form too. 
"Formal": ltac_expr ; [ ... ] is equivalent to [> ltac_expr ; [> ... ] .. ].
[[ ltac_expr ; [ phi_1 '|' ... '|' phi_i '|' ... '|' phi_n ] ]] = λg:G. [[ [> ltac_expr ; [> phi_1 '|' ... '|' phi_i '|' ... '|' phi_n ] .. ] ]] g.
*)

Goal P 1 /\ P 2 /\ (P 3 /\ P 4).
(* split. split.*)
do 2 split. (*apply to the focused goal*)
all: (unfold P; auto).
Qed.
(* "Unformal": Applies tac n times *)
(* "Formal": [[ do (natural | ident) ltac_expr3 ]] = λg:G. ltac_expr3 g. (n times)   *)



Goal P 1 /\ P 2 .
(* split. split.*)
split.
Fail progress simpl. 
all: progress (split; unfold P).
Qed.
(* "progress" ltac_expr3 *)
(* "ltac_expr" is evaluated to v which must be a tactic value. 
"Unformal":The tactic value v is applied to each focused subgoal independently. 
If the application of v to one of the focused subgoal produced subgoals equal to the initial goals (up to syntactical equality), 
then an error of level 0 is raised.
"Formal": [[ progress phi ]] := λg. if g==(phi g) then fail else phi.
*)

Goal P 1 /\ P 2 /\ P 1 /\ P 2 .
(* split. split.*)
repeat split.
Qed.
(* "Unformal": Applies tac until it fails
"Formal": repeat tac  = λg. if tac g == fail g then g else tac g  *)

Goal P 1 /\ P 2 /\ P 1 /\ P 2 .
try simpl.
repeat split.
Qed.

(* 
"Unformal": Applies tac and does not fail if tac fails 
"Formal": try tac = λg:G. if tac g == fail g then g else tac g. 
*)


(* once ltac_expr
ltac_expr is evaluated to v which must be a tactic value. 
The tactic value v is applied but only its first success is used. 
If v fails, once ltac_expr fails like v. 
If v has at least one success, once ltac_expr succeeds once, but cannot produce more successes. *)
(* "HELP" "once" *)
Goal forall (n:nat), P 1 /\ P 2  .
 ((intro;idtac "3") + idtac "4").
repeat split.
Qed.


Goal P 1 /\ P 2 /\ P 3 .
split. 2-2:split.
all: only 2-3:unfold P.
all: (only 1:unfold P).
all:auto.
Qed.
(* only selector: ltac_expr3 *)


Goal P 1 /\ P 2 /\ P 3 .
split. 2:split.
Fail all: (simpl || fail).
all: (simpl || unfold P).
all:auto.
Qed.
(* 
"Unformal":ltac_expr_1 and ltac_expr_2 are evaluated respectively to v1 and v2 which must be tactic values. The tactic value v1 is applied in each subgoal independently and if it fails to progress then v2 is applied. 
"Formal": ltac_expr_1 || ltac_expr_2 = λg:G. if (progress ltac_expr_1) g == fail g then ltac_expr_2 g else ltac_expr_1 g. 
*)



Goal P 1 /\ P 2 /\ P 3 .
split. 2:split.
(* all: (fail + unfold P). works *)
all: (unfold P + fail).

all:split.
Qed.

(* 

"Unformal": ltac_expr1 and ltac_expr2 are evaluated respectively to v1 and v2 which must be tactic values. 
The tactic value v1 is applied to each focused goal independently and 
if it fails or a later tactic fails, 
then the proof backtracks to the current goal and v2 is applied. 
"Formal": ltac_expr_1 + ltac_expr_2= λg. if ltac_expr_1 g == fail g then ltac_expr_2 g else ltac_expr_1 g. *)





Goal P 1 /\ P 2 /\ (forall n:nat, P 3) .
split. 2:split.

(* all:tryif intro then unfold P else auto.  *)
(* equivalent is *) all: (intro;unfold P) + auto.

all: (unfold P + fail).
all:split.
Qed.

(* 
tryif ltac_expr1 then ltac_expr2 else ltac_expr3
"Unformal": is a generalization of the biased-branching tactics above. The expression ltac_expr1 is evaluated to v1, which is then applied to each subgoal independently. For each goal where v1 succeeds at least once, ltac_expr2 is evaluated to v2 which is then applied collectively to the generated subgoals. The v2 tactic can trigger backtracking points in v1: where v1 succeeds at least once, tryif ltac_expr1 then ltac_expr2 else ltac_expr3 is equivalent to v1; v2. In each of the goals where v1 does not succeed at least once, ltac_expr3 is evaluated in v3 which is is then applied to the goal.
"Formal": tryif ltac_expr_1 then ltac_expr_2 else ltac_expr_3 = (ltac_expr1;ltac_expr_2) + ltac_expr_3
*)

Goal forall A B : Prop, A -> B -> (A->B).
idtac "start1".
intros.
(* тут он поискал в контексте, а он всегда получается матчит в контексте *)
match goal with
| H : _ |- _ => tryif idtac "apply " H ; apply H
                then idtac "[ok]"
                else (idtac "[notOk]"; fail)
end.
Qed.

Goal forall A B : Prop, A -> B -> (A->B).
idtac "start2".
intros.
match reverse goal with
| H : _ |- _ => 
                tryif idtac "apply " H ; apply H
                then idtac "[ok]"
                else (idtac "[notOk]"; fail)
end.
Qed.

Goal True /\ True.
idtac "start3".
match goal with
| |- context G [True/\True] => let x := context G [False] in idtac x
end.
auto.
Qed.




Ltac unfold_proj_pair :=
    repeat match goal with
    | [ |- context G [fst (?a, _)] ]
      => let G' := context G[a] in idtac "->" G';change G'
    | [ |- context G [snd (_, ?b)] ]
      => let G' := context G[b] in idtac "->" G';change G'
    end.

Ltac id_smt:=
  match goal with 
  | [|- context G1 [ True ] ] => 
    match goal with 
    | [|- context G2 [ nat ] ] => 
      let G' := context G1[nat] in 
      let G'' := context G2[bool] in 
      let X:= fresh "X" in 
      let X2:= fresh "X" in 
      assert(X: G')
      ;
      let X3 :=  fresh "X" in
      assert(X2: G') 
      ; intro; repeat (try apply 1; try auto)
      
    end
  end.

Ltac print_goal t := 
lazymatch goal with
  | [ |- context G [nat ->True] ] => 
            let G' :=  context G[nat] in 
            idtac  G "changed" G' 
  end.



Goal forall a:nat, forall b:nat, True.
    idtac "start4".
    print_goal asadasds.
assert(H: bool*bool).
apply pair.
1-2:apply true.
(* id_pair. *)
auto.
Qed.

Ltac f t := try lazymatch t with
           | context [ (~ ?t) ] => idtac "?t = " t; fail
           | _ => idtac
           end.

Goal True.
idtac "start5".
f ((~ True) <> (~ False)).
auto.
Qed.

Ltac input a :=
  idtac a
  (* match a with 
  |(fun d : ?c => ?T) => idtac d c T
  end *)
  .

Goal True.
idtac "start6".
input auto.


auto.
Qed.