\documentclass[12pt]{article}

% = Подключение пакетов =
%  - Поддержка русских букв -
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}

\usepackage{textcomp}
\usepackage{stmaryrd}
\usepackage[english,russian]{babel}
%  - Размеры полей -
\usepackage[right=1.5cm,top=2cm,left=3cm,bottom=2cm]{geometry}
%  - Отступ в начале первого абзаца -
\usepackage{indentfirst}
%  - Титульный лист с содержанием -
\usepackage{mdiss}
%  - Гиперссылки (url, \ref, \cite) -
\usepackage{hyperref}

% = Общие настройки =
%  - Полуторный межстрочный интервал -
\linespread{1.5}
%  - Разрешить разреженные строки и запретить перенос -
\sloppy
\hyphenpenalty=10000
\exhyphenpenalty=10000


% = (!!!) Здесь впишите свои данные =
%  - Название работы -
\mdissTitle{Решение задачи проверки модели в исчислении индуктивных конструкций}
%  - Как вас зовут. В РОДИТЕЛЬНОМ ПАДЕЖЕ -
\mdissAuthor{Ларочкин Петр Викторович}
%  - Степень, должность и Фамилия И.О. научного руководителя -
\mdissSupervisorTitle{к.ф.-м.н.,~доцент}
\mdissSupervisorName{Подымов~В.\,В.}
%  - Если показывается неправильный год, то раскомментируйте и напишите правильный -
% \mdissYear{2019}
\newtheorem{theorem}{Теорема}
\begin{document}
  \mdissPutTitleContents

  \section{Введение}
  
  
Темпоральная логика — логика, язык которой содержит средства описания взаимосвязей логических значений, изменяющихся с течением времени \cite{Clark}. Распространненными темпоральными логиками являются логика линейного времени (\textit{LTL}) и логика ветвящегося времени (\textit{CTL}). Их обобщением является расширенная логика ветвящегося времени (\textit{CTL*}). Темпоральные логики активно применяются в задачах верификации программ (проверки свойств программ). Утверждения о свойствах программы можно описать с помощью языка темпоральной логики. 
Программу можно описать как систему с конечным числом состояний и отношением перехода. Одним из вариантов такой системы может быть модель Крипке. Задача проверки выполнимости построенных таким образом утверждений на модели Крипке называется проверка модели (\textit{model checking}).

\textit{Coq} -- интерактивное средство доказательства теорем. Это средство позволяет строить и доказывать теоремы, и оно же проверяет правильность построенного доказательства, обеспечивая этим корректность доказанной теоремы с высокой степенью доверия - такой же, как и к правильности работы самого средства \textit{Coq}.
% которые имеют высокую степень доверия, и оно же проверяет правильность построенного доказательства. 
Правильность работы \textit{Coq} обеспечивается тем, что ядро \textit{Coq} реализовано довольно простым способом, чтобы сократить вероятность ошибки, к тому же теория, лежащая в основе, является надежной. 
\textit{Coq} активно применяется для верификации программного обеспечения \cite{CompCert} \cite{SoftwareFoundations6} и для доказательств утверждений из математики\cite{mathcomp}. 

% Основа построения доказательства теорем в \textit{Coq} -- это заложенное в нем исчисление конструкций \cite{Coquand}. Исчисление -- это система, которая определяет правила построения доказательств теорем. Она включает в себя алфавит для записи высказываний, синтаксис формул, множество аксиом (формул, верных без доказательства) и множество правил вывода одних формул из других. В исчислении конструкций такими формулами являются типы. 
% В \textit{Coq} можно создавать собственные индуктивные типы. 
% Через типы можно описать цель, то есть утверждение, которое необходимо доказать. 
Основным инструментом для построения доказательств в \textit{Coq} являются тактики. Тактики -- это особые команды для автоматизированного построения доказательства теоремы, причем такие, что могут быть реализованы и самим пользователем.
% с возможностью проверить корректность. 
% Доказательство в \textit{Coq} -- это перечисление тактик.
В \textit{Coq} одним из инструментов, позволяющих описывать новые тактики, является встроенный язык тактик \textit{Ltac}\cite{LtacRef}. 
% Эти средства не нарушают надежность этих доказательств, так как в итоге получается применение уже проверенных <<атомарных>> тактик.

Существует работы \cite{2007}\cite{thesis}\cite{2003}, посвященные анализу темпоральных логик в \textit{Coq}.
В работе \cite{2003} автор реализует операторы \textit{LTL} и доказывает связанные с ними свойства. 
В работе \cite{2007} автором была предложена формализация модели Крипке и формул \textit{CTL*} в \textit{Coq}. При помощи этой формализации доказаны средствами \textit{Coq} некоторые свойства языка \textit{CTL*} и соответствующего варианта задачи проверки модели. 
В работах \cite{thesis}\cite{thesis_article} автор провел обширное исследование, в котором удачно формализовал операторы \textit{CTL}, модель Крипке и реализовал некоторые логические системы в \textit{Coq}. Главным результатом этой работы является утверждения о корректности и полноте некоторых систем доказательств относительно задачи проверки выполнимости формул \textit{CTL} на моделях Крипке. 
Стоит отметить, что в этой работе построены новые тактики для применения в доказательствах утверждений о конечных множествах. Однако ни одна из приведенных работ не предоставляет автоматического средства доказательства утверждения о выполнимости формулы на модели Крипке.
Такое средство (тактика) представляет интерес по крайней мере по двум причинам. Во-первых, в качестве вспомогательного инструмента для доказательства теорем, если в процессе доказательства возникает необходимость обосновать выполнимость конкретной формулы на конкретной модели - аналогично широко применяющейся тактике \textit{lia} \cite{micromega}, автоматически доказывающей существование решения конкретной системы линейных уравнений над целыми числами. Во-вторых, для исследования возможностей преобразования известных алгоритмов проверки модели в алгоритмы доказательства соответствующих теорем.







% Целью магистерской диссертации были формальная постановка задачи проверки модели терминах \textit{Coq}, построение формальных синтаксиса и семантики языка \textit{Ltac} и базовых тактик, основываясь на их документации \cite{Ltac} и на работе \cite{LtacRef}, содержащие описания, близкие к формальным, но не вполне строгие, разработатка алгоритма, записанного в терминах формализованных элементов языка \textit{Ltac} и решающего рассматриваемую задачу проверки модели, обоснование корректности и полноты построенного алгоритма.
% В результате, была формализована задача проверки модели в терминах \textit{Coq}, была построена основная часть формального синтаксиса и семантики языка \textit{Ltac}, необходимого для описания алгоритма, был разработан алгоритм, записанный в терминах формализованных элементов языка \textit{Ltac} и решающий рассматриваемую задачу проверки модели, были обоснованы корректность и полнота разработанного алгоритма.


Целью магистерской диссертации была разработка и исследование средства автоматического доказательства теорем о выполнимости формул \textit{CTL} на моделях Крипке.
Для достижения этой цели требовалось решить следующие задачи:
\begin{enumerate}
    \item[1.] Поставить обозначенную задачу выполнимости формально в терминах \textit{Coq}.
    \item[2.] Разработать тактику доказательства теоремы, обозначающей выполнимость заданной формулы на заданной модели в формальной постановке, на языке \textit{Ltac} - то есть разработать алгоритм проверки модели в особой вычислительной модели, предназначенной для вывода логических суждений.
    \item[3.] Описать формальные синтаксис и семантику фрагмента языка \textit{Ltac}, потребовавшегося в разработанной тактике, основываясь на технической документации \cite{Ltac} и работе \cite{LtacRef}, содержащих описания, близкие к формальным, но не вполне строгие. Следует отметить, что формальные синтаксис и семантика \textit{Ltac} изложены в диссертации \cite{LtacFull}, но это изложение настолько объёмно (102 страницы) и содержит столько деталей и возможностей языка, что его изучение и использование оказалось практически невозможным.
    \item[4.] Обосновать корректность и исследовать полноту разработанной тактики. Корректность означает, что если тактикой строится доказательство теоремы о выполнимости формулы на модели из формальной постановки задачи, то формула действительно выполняется на модели. Под исследованием полноты понимается строго обоснованное обозначение класса формул и моделей, для которых тактика успешно строит доказательство.
\end{enumerate}

% Данная работа имеет следующую структуру. 
В разделе 4.1 опысывается постановка задачи проверки модели в терминах \textit{Coq}. В разделах 4.2, 4.3 приводится описание части синтакстиса и семантики языка \textit{Ltac}, а также необходимых базовых тактик. В разделе 4.4 описываются какие модели Крипке будут рассматриваться для решения задачи проверки модели. В разделе 4.5 приводится поэтапное описание тактики, доказывающей выполнимость формулы на модели. В разделе 4.6 и 4.7 приводится соответственно обоснование корректности и полноты построенной тактики для рассматриваемых моделей и формул определенного вида.



\section{Основные понятия}
\subsection{Логика ветвящегося времени (CTL)}
Понятия, изложенные в данном разделе, приводятся, например, в \cite{Clark}.

Пусть задано множество атомарных высказываний $AP$.
Структура Крипке — это четверка ($S$, $S_{0}$, $T$, $L$), где
\begin{itemize}
    \item $S$ — конечное множество состояний
    \item $S_{0}$ — множество начальных состояний, $S_{0} \subset S $
    \item $T$ — $T \subseteq S \times S$ — отношение переходов, обладающее свойством тотальности: для любого состояния $s_1$ существует состояние $s_2$, такое что $(s_1, s_2) \in T$
    % двуместный предикат отношения перехода, $T: S \rightarrow S \rightarrow \{ True, False \} $ 
    \item $L$ — функция разметки состояния, $L: S \rightarrow 2^{AP} $.
\end{itemize}

Путь в модели Крипке $M$ из состояния $s_0$ — это бесконечная последовательность состояний $\pi$ = $s_0, s_1...$, где $(s_{i}, s_{i+1}) \in T$ ($i = 0, 1, 2...$) модели Крипке \textit{M}. 
Обозначим $i$-ый суффикс пути $\pi^{i} = s_{i}, s_{i+1},...$

Синтаксис логики ветвящегося времени (\textit{CTL}) определяется следующей БНФ:
$$\phi ::= p | \neg \phi | \phi \vee \phi | \phi \wedge \phi | 
\phi \Rightarrow \phi| EX\phi | AX\phi | AF\phi | EF\phi | AG\phi | EG\phi | \phi AU \phi|\phi EU \phi| \phi AR \phi,$$
где $p \in AP,$ $\phi$— формула логики ветвящегося времени.

Выполнимость формулы $\phi$ в состоянии $s$ модели $M$: $M, s \vDash \phi$ определяется следующим образом:
\begin{enumerate}

    \item $M, s \vDash p \Leftrightarrow p \in L(s) $
    \item $M, s \vDash \neg \phi \Leftrightarrow M, s \nvDash \phi$
    \item $M, s \vDash \phi_1 \vee \phi_2  \Leftrightarrow M, s \vDash \phi_1$ или $M, s \vDash \phi_2 $
    \item $M, s \vDash \phi_1 \wedge \phi_2 \Leftrightarrow M, s \vDash \phi_1$ и $M, s \vDash \phi_2 $
    \item $M, s \vDash \phi_1 \Rightarrow\ \phi_2 \Leftrightarrow M, s \nvDash \phi_1$ и $M, s \vDash \phi_2 $
    
    \item $M, s \vDash EX\phi \Leftrightarrow$ в $M$ существует путь $\pi$ из состояния $s$, что  $M, \pi^{1} \vDash \phi$
    
    \item $M, s \vDash EF\phi \Leftrightarrow$ в $M$ существует такой путь $\pi$ из состояния $s$, такое $k \geq 0$, что $M, \pi^{k} \vDash \phi$ 
    
    \item $M, s \vDash EG\phi \Leftrightarrow$ в $M$ существует такой путь $\pi$ из состояния $s$, что для любого $k \geq 0$ верно, что $M, \pi^{k} \vDash \phi$ 
    
    \item $M, s \vDash \phi_1 EU \phi_2 \Leftrightarrow$ в $M$ существует путь $\pi$ из состояния $s$, существует такое $k \geq 0$, что $M$, $\pi^{k} \vDash \phi_2$ и для каждого $0 \leq j < k$ верно соотношение $M, \pi^{j} \vDash \phi_1$
    
    \item $M, s \vDash AX\phi \Leftrightarrow$ для любого пути $\pi$ из состояния $s$ в модели $M$ верно соотношение $M, \pi^{1} \vDash \phi$ 
    
    \item $M, s \vDash AF\phi \Leftrightarrow$ для любого пути $\pi$ из состояния $s$ в модели $M$ существует такое $k \geq 0$ верно, что $M, \pi^{k} \vDash \phi$ 
    
    \item $M, s \vDash AG\phi \Leftrightarrow$ для любого пути $\pi$ из состояния $s$ в модели $M$, для любого $k \geq 0$ верно, что $M, \pi^{k} \vDash \phi$ 
    
    \item $M, s \vDash \phi_1 AU \phi_2 \Leftrightarrow$ для любого пути $\pi$ из состояния $s$ в модели $M$ верно, что существует такое $k \geq 0$, что $M$, $\pi^{k} \vDash \phi_2$ и для каждого $0 \leq j < k$ верно соотношение $M, \pi^{j} \vDash \phi_1$

    \item $M, s \vDash \phi_1 AR \phi_2 \Leftrightarrow$ для любого пути $\pi$ из состояния $s$ в модели $M$ верно, что для любого $k \geq 0$ верно соотношение $M, \pi^{k} \vDash \phi_2$ как минимум до тех пор, пока не будет верным соотношение $M, \pi^{t} \vDash \phi_1$, где $t \geq k$

    \item $M, s \vDash \phi_1 ER \phi_2 \Leftrightarrow$ существует путь $\pi$ из состояния $s$ в модели $M$ верно, что для любого $k \geq 0$ верно соотношение $M, \pi^{k} \vDash \phi_2$ как минимум до тех пор, пока не будет верным соотношение $M, \pi^{t} \vDash \phi_1$, где $t \geq k$
    
\end{enumerate}

Далее, будет рассматриваться укороченный синтаксис \textit{CTL}, состоящий из элементов $\{p,\ \neg,\ \xrightarrow{},\ AX,\ AR,\ AU\}$. Любая формула \textit{CTL} может быть выражена с помощью этого набора, так как $\{\neg,\ \xrightarrow{}\}$ -- это полная система в алгебре логики, $\{AX,\ AU,\ EU\}$ -- темпоральные операторы, через которые можно выразить остальные темпоральные операторы, как показано в \cite{Karpov} с учётом эквивалентности  ($\phi_1EU\phi_2)= \neg(\neg\phi_1AR\neg\phi_2)$ можно заменить оператор $EU$ на $AR$.


Пусть заданы модель Крипке $M = (S, S_0, R, L)$ и \textit{CTL}-формула $\phi$. Задача проверки модели заключается в том, чтобы проверить включение $S_0 \subset S_{\phi},$ где $S_{\phi} = \{s \in S | M,s \vDash \phi \}$. 


\subsection{Исчисление индуктивных конструкций и доказательство теорем}

Понятия, изложенные в данном разделе, приводятся, например, в \cite{CIC}\cite{Coquand}\cite{CHC}\cite{CHCCOQ}.

\subsubsection{Исчисление конструкций}
Основные объекты в исчислении конструкций -- это термы.
Синтаксис термов над множеством переменных $X$ 
и множеством типов 
$$Sorts=\{Prop\} \cup (\cup_{i \in N} \{Type_i\})$$
задается следующей БНФ:
$$term ::=\ x\ |\ s\ |\ (\lambda\ (x : term).\ term)\ |\ (term\ term)\ |\ \Pi (x:term),\ term,$$ 
где $s \in Sorts$, $x \in V$.

Каждому терму, построенному согласно описанной выше БНФ, 
ставится в соответствие тип (или, по-другому, говорится, что этот терм имеет тип), который также является термом.
Запись <<$y:K$>> обозначает, что терм обозначенный через переменную $y$ имеет тип $K$.

Контекстом будем называть конечное множество, элементы которого имеют вид $x : T$ или $x := t : T$, где $x$ - переменная, $t$ - терм и $T$ - тип этого терма.

Свободная переменная -- это переменная, которая не связана ни одним из кванторов $\lambda$, $\Pi$. Через $FV(M)$ обозначим множество свободных переменных в терме $M$.

Запись $t\{x/u\}$ обозначает терм $t$, в котором свободная переменная $x$ заменена на терм $u$. Будем говорить, что терм $t\{x/u\}$ является уточнением терма $t$. Cуждение о типе -- это запись 
$$\Gamma \vdash t: A,$$ 
где $\Gamma$ -- это контекст, $\ t$ -- это терм,  $A$ -- это тип. 

Основные правила вывода исчисления конструкций:
$$\frac{\Gamma \vdash }
        {\Gamma \vdash Prop: Type_1}, \ \  
\frac{\Gamma \vdash }
    {\Gamma \vdash Type_i: Type_{i+1}}, \ \ 
\frac{\Gamma \vdash \ \ \ \ x:A \in \Gamma}
        {\Gamma \vdash x:A},\ \ 
\frac{\Gamma \vdash A:s \ \ \ \ x \notin \Gamma \ \ \ \  s\in Sorts}
{\Gamma, x:A \vdash },$$
        
$$\frac{\Gamma, x:A \vdash t:B}
        {\Gamma \vdash \lambda x:A.t:\Pi (x:A), B},\ \ 
    \frac{\Gamma \vdash f:\Pi (x:A), B \ \ \ \  \Gamma \vdash a: A}
        {\Gamma \vdash f\ a:B\{x/a\}},\ \ 
        \frac{\Gamma, x:A \vdash B:Prop} 
        {\Gamma \vdash \Pi (x:A), B:Prop},$$

$$\frac{\Gamma, x:A \vdash B:Type_i \ \ \ \  \Gamma, \vdash A:Type_i}
        {\Gamma \vdash \Pi (x:A), B:Type_i},\ \ 
    \frac{\Gamma \vdash t: T \ \ \ \ x \notin \Gamma}
        {\Gamma, x:=t:T \vdash },$$
где  $\Gamma$-- это контекст, $x \in V$, $Sorts=\{Prop\} \cup (\cup_{i \in N} \{Type_i\}).$

Запись $\Gamma \vdash$ является суждением о типе, которое означает, что контекст $\Gamma$ построен корректно (согласно правилам). Суждение такого вида будем называть ослабленным суждением о типе.
Будем говорить, что терм $t$ типа $T$ выводим в контексте $\Gamma$, если можно построить последовательность суждений о типе, построенные с помощью правил, согласно которым верно следующее суждение о типе
$$\Gamma \vdash t: T.$$

Согласно устройству основных правил, каждому терму $t$ можно сопоставить реализуемое им отображение или множество реализуемых объектов.
% (*домен* типа).

\begin{itemize}
    \item Терму $(\lambda\ (x: term_1).\ term_2)$
отвечает отображение с аргументом $x$ типа $term_1$, 
возвращающее для значения $v$ этого аргумента 
значение выражения $term_2$ на $v$.

    \item Терму $(term_1\ term_2)$ отвечает результат 
применения отображения, записанного как $term_1$, к аргументу, 
записанному как $term_2$.

    \item Терму $\Pi (x:term_1),\ term_2$
отвечает семейство типов (термов), которые образуются при подстановке типа $x$ в $term_2$.

    \item Запись <<$A \xrightarrow{} B$>> обозначает терм $\Pi (x:A). B$, где $x \notin FV(B)$.
    
    \item Запись <<$x$>>, $x \in V$, означает переменную $x$, имеющую тип, заданный контекстом.
    
    \item Запись <<$s$>>, $s \in Sorts$, обозначает тип из заданного множества $Sorts$, тип которого определяется согласно правилам вывода.
    
    
\end{itemize}

Будем использовать следующее двуместное отношение $\beta$-редукции $\xrightarrow{\beta}$ на множестве термов, которое определяется следующим образом: 
$$(\lambda\ (x: A).\ M)\ N \xrightarrow{\beta} M\{x/N\}$$

\subsubsection{Индуктивные типы}
Пусть $Names$ и $Constr$ -- это соответственно множество имен типов и имен конструкторов.
Индуктивный тип -- это запись $$((I\ parameters:\ Ar),\ constructors),$$ где

\begin{itemize}
    \item $I,\ I \in Names$ -- имя индуктивного типа,
    \item $parameters = p_1:P_1$, ..., $p_n:P_n$ -- это параметры индуктивного типа $I$,
    \item $Ar=\Pi(q_1:Q_1),...,\Pi(q_w:Q_w), s$ -- это тип этого индуктивного типа, $s \in Sorts$,
    \item $constructors = \{constr_1: c_1,...,constr_l: c_l \}$ -- это конечное множество конструкторов, которые имеют имя $constr_i$, $constr_i \in Constr$, и тип $c_i$, который имеет следующий вид (разные для каждого конструктора) $$c_i=\Pi\ parameters,(\Pi(x_{1} : A_{1}),(\Pi(x_{2}: A_{1}),...(\Pi(x_{k} : A_{k}),\ I\ parameters)...)).$$
\end{itemize}

Обозначим через $\Gamma_I$ контекст $$\Gamma_I = [(I\ parameters:\ Ar),\ (constr_1: c_1),...,(constr_m: c_m)].$$

Для каждого используемого индуктивного типа $I$ и каждого конструктора $constr_i$ описанного выше вида в исчисление индуктивных конструкций добавляется правило
$$ \frac{}{\Gamma_I \vdash constr_i\ x_1\ ...\ x_k : I\ parameters}.$$

То есть запись ($constr_i\ x_1\ ...\ x_k$) для конструктора и для аргументов соответствующих типов является термом этого типа.
Множество термов этого индуктивного типа состоит из всех термов вида ($constr_i\ t_1\ ...\ t_k$), для которых можно вывести суждение о том, что эти термы имеют тип $I\ parameters$ в контексте $\Gamma_I$.
Указанный терм $constr_i\ t_1\ ...\ t_k$ будем называть термом, построенным конструктором $constr_i$.

Индуктивный тип также имеет дополнительные ограничения корректности построения \cite{CIC}, однако для дальнейшего описания эти ограничения не потребуются. Далее будут использоваться индуктивные типы, которые выполняют эти ограничения и проверены средством \textit{Coq}.

Будем записывать $x \in y$, если терм $x$ является подтермом терма $y$.
Например, рассмотрим индуктивный тип $Nat$ натуральных чисел, который можно описать следующим образом:
$$(Nat:Type, \{O: Nat, S: Nat \xrightarrow{} Nat\}).$$

Контекст $$\Gamma_{Nat} = [Nat:Type, O:Nat, S:Nat \xrightarrow{} Nat] $$

Согласно, правилам вывода можно построить следующие суждения о типе

$$\Gamma_{Nat} \vdash O: Nat$$
$$\Gamma_{Nat} \vdash (S\ O): Nat$$
$$\Gamma_{Nat} \vdash (S\ (S\ O)): Nat$$
$$...$$

Таким образом, термами индуктивного типа $Nat$ являются $O,\ (S\ O),\ (S\ (S\ O))...$ 

\subsubsection{Cопоставление по шаблону}
Пусть:
\begin{itemize}
    \item $I\ parameters$ -- индуктивный тип $I$ с параметрами $parameters$
    \item $f_1,...,f_n$ -- термы типа $P$, $FV(P) = \emptyset $
    \item для каждого $i$, множество $FV(f_i)=\{u_{i_0}, u_{i_1}, ... , u_{i_m}\}$
    \item $x\ :\ I\ parameters$ -- переменная $x$ типа $I\ parameters$
    \item $c_i$ -- $i$-ый конструктор индуктивного типа $I\ parameters$, с аргументами $$x_{i_1}\ :\ A_{i_1}, ..., x_{i_m}\ :\ A_{i_m}$$
\end{itemize}


Тогда будем считать термом следующую запись
\begin{align*}
& match\ x : (I\ parameters)\ with \\
& |\ c_1\ x_{1_1} ... x_{1_m} \Rightarrow f_1\{u_{1_0}/x\}\{u_{1_1}/x_{1_1}\}...\{u_{1_m}/x_{1_m}\}\\
& \ ... \\
& |\ c_n\ x_{n_1} ... x_{n_m} \Rightarrow f_n\{u_{n_0}/x\}\{u_{n_1}/x_{n_1}\}..\{u_{n_m}/x_{n_m}\} \\
& end: P \\
\end{align*}

Указанный выше терм (обозначим его через $m$) имеет тип $(I\ parameters) \xrightarrow{} P$.
Терму $m$ отвечает отображение, принимающее аргумент $x$ типа $(I\ parameters)$ и возвращающее значение $v$ типа $P$, устроенное следующим образом:
если $x = c_i\ x_{i_1},\ ...,\ x_{i_m}$, то $v = f_i\{u_{i_0}/x\}\{u_{i_1}/x_{i_1}\}...\{u_{i_m}/x_{i_m}\}.$

Будем использовать двуместное отношение $\iota$-редукции 
$\xrightarrow{\iota}$ на множестве термов, которое определяется следующим образом:
$$((m)\ t):P\ \xrightarrow{\iota}\ f_k\{u_{k_0}/t\}\{u_{k_1}/x_{k_1}\}...\{u_{k_m}/x_{k_m}\},$$
где $t$ построен $k$-ым конструктором индуктивного типа $I\ parameters$.

\subsubsection{Рекурсивное отображение}

Пусть:
\begin{itemize}
    \item $\{A_1,...,A_{n-1},A_{n+1},...,A_m \}$-- типы, $A_n$ -- индуктивный тип,
    \item терм $t$ имеет тип $B$ в контексте 
    $[(f : \Pi(x_1 : A_1), ...,\Pi(x_m : A_m), B), (x_1 : A_1)...(x_m : A_m)]$,
    \item в записи $f\ u_1\ ...\ u_m$ в терме $t$, терм $u_n$ структурно меньше чем $x_n$, то есть $u_n \in x_n$ и $x_n \neq u_n$
\end{itemize}

Тогда будем считать термом следующую запись:
$$fixpoint\ f\ (x_1:A_1)...(x_m:A_m)\{struct\ x_n\}:B:=t$$

Этот терм имеет тип $(\Pi (x_1:A_1),...,\Pi (x_m:A_m), B)$, и ему отвечает отображение, для аргументов $u_1 ... u_m$ типов $A_1 ... A_m$ соответственно возвращающее значение $v$, устроенное следующим образом:

\begin{enumerate}
 \item Рассматривается терм $t$, в котором после подстановки переменных $x_1,...,x_m$ записи вида $f\ u_1...u_m$ заменяются на термы вида $t\{u_1/x_1\}...\{u_m/x_m\}$.
    \item К этому терму применяются правила $\beta$ и $\iota$ редукции. Процесс повторяется до тех пор, пока к терму нельзя будет применить правила редукции и пока в терме присутствуют записи вида $f\ u_1...u_m$.
    \item Искомое значение $v$ - это последний полученный терм, к которому невозможно применить правила редукции и в котором нет записи вида $f\ u_1...u_m$.
\end{enumerate}

Построенный терм может быть включен в контекст и имеет следующий вид: 
$$f:= (fixpoint\ f\ (x_1:A_1)...(x_m:A_m)\{struct\ x_n\}:B:=t):(\Pi (x_1:A_1),...,\Pi (x_m:A_m), B).$$

\subsubsection{Исчисление индуктивных конструкций (CIC)}
Исчисление индуктивных конструкций ($CIC$) -- это расширение исчисления конструкций, в котором есть возможность определять индуктивный тип, строить термы, используя дополнительно выражения $match$ и $fixpoint$.

\subsubsection{Соответствие Карри--Говарда}
Соответствие Карри-Говарда  применительно к исчислению индуктивных конструкций  - это соответствие между элементами исчисления индуктивных конструкций и исчислений, предназначенных для конструктивного доказательства высказываний на языке логики предикатов.
Это соответствие устроено следующим образом.
\begin{itemize}
    \item Квантору $\Pi$ сопоставляется квантор всеобщности.
    \item Каждый тип $A$ типа $Prop$ расценивается как формула логики предикатов той же структуры. Например, тип $A \xrightarrow{} B$ расценивается как формула логики предикатов $A \Rightarrow B$, где $A$ и $B$ имеют тип $Prop$.
    
    \item Запись $(t : A)$, где $t$ - терм и $A$ - тип, трактуется как утверждение о том, что $t$ является доказательством утверждения $A$.
    \item Запись $(x := t : A)$ трактуется как присвоение имени $x$ доказательству $t$ утверждения $A$.
    \item Суждение о типе $\Gamma \vdash t : A$ трактуется как утверждение о том, что $t$ является доказательством утверждения $A$ в предположении о наличии доказательств, записанных в контексте $\Gamma$.
    
Например, пусть задан контекст
$$\Gamma = \Gamma_{Nat} \cup [A:Prop, B:Prop, (l: Nat \xrightarrow{} B), (p:B \xrightarrow{} A)],$$ 
где $A$, $B$ -- утверждения, $l$ -- доказательство утверждения, того что для любого терма типа $Nat$ верно утверждение $B$, $p$ -- доказательство утверждения $B \Rightarrow A$. Выведем терм доказательства для суждения $A$, используя правила вывода.
То есть покажем суждение $\Gamma \vdash t: A$ выводимо.

\begin{center}
    \begin{tabular}{c}
         $\Gamma \vdash O: Nat$\\
         \hline
         $\Gamma \vdash (l\ O): B$\\
         \hline
         $\Gamma \vdash (p\ (l\ O)): A$
    \end{tabular}
\end{center}
Таким образом, выводимо суждение $\Gamma \vdash t: A$, где $t=(p\ (l\ O))$. То есть $t$ является доказательством утверждения $A$ в предположении о наличии доказательств, записанных в контексте $\Gamma$. 
\end{itemize}


\newpage
\section{Постановка задачи}
В магистерской диссертации требовалось выполнить следующее:
\begin{enumerate}
    \item [1.] Поставить формально задачу проверки модели, изложенную в разделе 2.1, в терминах исчисления индуктивных конструкций.
    \item [2.] Предложить формальные синтаксис и семантику фрагмента языка \textit{Ltac} и базовых тактик, которые потребуется использовать для решения задачи проверки модели в терминах исчисления индуктивных конструкций.
    \item [3.] Разработать алгоритм, записанный в терминах формализованных элементов языка \textit{Ltac},  для доказательства выполнимости или невыполнимости любой заданной формулы на заданной модели Крипке (или для формул и моделей какого-либо достаточно нетривиального подкласса).
    \item[4.] Обосновать корректность и полноту разработанного алгоритма.
\end{enumerate}  
% \clearpage
\section{Основная часть}
\subsection{Постановка задачи проверки модели в исчислении индуктивных конструкций}
Данный раздел посвящен постановке задачи проверки модели относительно формул \textit{CTL} в терминах исчисления индуктивных конструкций. 
% В постановке задачи использовались индуктивные типы, лежащие в основе программного кода из стандартной библиотеки\cite{lib} \textit{Coq} и из работы\cite{thesis}\cite{thesisgithub}. Построенное математическое описание этих индуктивных типов представлено ниже. 
% Удобное программное представление модели Крипке было перестроено в индуктивный тип, в который был добавлен параметер $init$ для обозначения множества начальных состояний для соответствия с постановкой задачи из раздела 2.1. После этого потребовалось добавить термы, соответствующие отображениям, которые на вход принимают терм модели Крипке и возвращают один из параметров его конструктора.

% Программный код на языке \textit{Coq}, который соответствует формализации постановки задачи приведен в приложении. 


\subsubsection{Вспомогательные индуктивные типы}
В этом подразделе приводится математическое описание индуктивных типов, лежащие в основе программного кода из стандартной библиотеки \textit{Coq}\cite{lib}.

\paragraph{Формализация квантора существования в терминах \textit{CIC}.}\mbox{}

Индуктивный тип $ex$, который соответствует квантору существования логики предикатов, устроен так:
\begin{align*}
& ((ex(A:Type)(P:A\xrightarrow{}Prop):Prop), \{ \\ 
& \ \ (ex_{intro} : \Pi (A:Type),\Pi (P:A\xrightarrow{}Prop), \Pi(x:A), P\ x \xrightarrow{} ex\ A\ P) \}).
\end{align*}
Построение терма типа $ex$ возможно с помощью единственного конструктора $ex_{intro}$ с параметрами: 
\begin{enumerate}
    \item тип терма $A$, для которого нужно показать существование,
    \item формулировка $P$ утверждения о терме,
    \item терм типа $A$ и доказательство суждения $P$ для него.
\end{enumerate}

Таким образом, для того, чтобы доказать что существует терм, удовлетворяющий утверждению $P$, необходимо предоставить сам терм и доказательство выполнения термом формулировки $P$ для этого терма.

Индуктивный тип $ex2$, который также соответствует квантору существования логики предикатов, устроен так:

\begin{align*}
& ((ex2:\Pi(A:Type),\Pi(P:A\xrightarrow{}Prop),\Pi(Q:A\xrightarrow{}Prop),Prop), \{ \\ 
& (ex_{intro2} : \Pi (A:Type),\Pi (P:A\xrightarrow{}Prop),\Pi(Q:A\xrightarrow{}Prop),\\ & 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \Pi(x:A), P\ x \xrightarrow{} Q\ x \xrightarrow{} ex2\ A\ P\ Q\})) \}).
\end{align*}

Построение терма типа $ex2$ схоже с построением терма типа $ex$, но еще требуется доказательство для формулировки $Q$.

Введем обозначение <<\textit{exists y: A, p}>>, которое означает индуктивный тип <<$exists\ A\ (\lambda (y:A).p)$>>. Введем обозначение  <<\textit{exists2 x : A, p} \& \textit{q}>>, которое означает индуктивный тип
<<$exists2\ A\ (\lambda (x:A). p) (\lambda (x:A). q)$>>.

\paragraph{Формализация дизъюнкции в терминах \textit{CIC}}\mbox{}

Индуктивный тип $or$, который соответствует дизъюнкции из алгебры логики, устроен так:

\begin{align*}
& ((or(A:Prop)(B:Prop):Prop), \{ \\ 
& \ \ (or\_introl : \Pi(A:Prop), \Pi (B:Prop), A \xrightarrow{} or\ A\ B ), \\
& \ \ (or\_intror : \Pi(A:Prop), \Pi (B:Prop), B \xrightarrow{} or\ A\ B ) \}).
\end{align*}

Построение терма типа $or$ возможно с помощью одного из его конструкторов, которым требуется доказательство одного из двух утверждений.

Введем обозначение  <<$A \lor B$>> , которое означает тип 
\textit{(or A B)}.

\paragraph{Формализация конъюнкции в терминах \textit{CIC}}\mbox{}

Индуктивный тип $and$, который соответствует конъюнкции из алгебры логики, устроен так:

\begin{align*}
& ((and(A:Prop)(B:Prop):Prop), \{ \\ 
& \ \ (conj : \Pi(A:Prop), \Pi (B:Prop), A \xrightarrow{} B \xrightarrow{} and\ A\ B ) \}).
\end{align*}

Построение терма типа $and$ возможно с помощью одного конструктора, которому требуется доказательство двух утверждений.

Введем обозначение  <<$A \wedge B$>> , которое означает тип 
\textit{(and A B)}.

\paragraph{Формализация отношения $=$ в терминах \textit{CIC}}\mbox{}

Индуктивный тип $eq$, который соответствует двуместному отношению $=$ для термов, устроен так:

\begin{align*}
& ((eq (A : Type) (x : A): A \xrightarrow{} Prop), \{ \\ 
& \ \ (eq_{refl} : \Pi(A : Type) (x : A), eq A x x ), \\
 \}).
\end{align*}

Терм типа $eq\ A\ x\ y$ можно построить только в том случае, если терм $x$ типа $A$ идентичен терму $y$.

Введем обозначение  <<$(x:A) = (y:A)$>> , которое означает тип \textit{(eq A x y)}.

\paragraph{Формализация отношения $<$ в терминах \textit{CIC}}\mbox{}

Индуктивный тип $le$, который соответствует двуместному отношению $\leq$ на множестве натуральных чисел, устроен так:

\begin{align*}
& ((le (n : nat): nat \xrightarrow{} Prop), \{ \\ 
& \ \ (le_n : \Pi(n:nat), le\ n\ n ), \\
& \ \ (le_S : \Pi(n:nat), \Pi(m : nat), le\ n\ m \xrightarrow{} le\ n\ (S\ m)) \}).
\end{align*}

Терм типа $le$ строится с помощью конструкторов следующим образом: если два числа являются равным, то применяется конструктор $le_n$, если два числа не являются равными, тогда для построения нужно рекурсивно построить доказательства конструктором $le_S$, того что отношение выполняется для второго аргумента на единицу меньше до тех пор, пока два терма не станут равными.

Введем обозначение  <<$n < m$>> , которое означает тип \textit{(le (S n) m)}.

\paragraph{Формализация $false$ в терминах \textit{CIC}}\mbox{}

Индуктивный тип $False$, который соответствует логическому значению $false$ из алгебры логики, устроен так:

\begin{align*}
& ((False : Prop), \{ \}).
\end{align*}

Терм индуктивного типа $False$ невозможно построить.

\subsubsection{Основные индуктивные типы}
В этом подразделе приводится математическое описание индуктивных типов из работы \cite{thesis}\cite{thesis_article}\cite{thesisgithub}.

\paragraph{Формализация модели Крипке в терминах \textit{CIC}}\mbox{}

Индуктивный тип $sts$, соответствующий моделям Крипке, устроен так:


\begin{align*}
& ((sts:Type), \{ \\ 
& \ \ (STS: \\
& \ \ \Pi(state:Type), \\ 
& \ \ \Pi(trans : state \xrightarrow{} state \xrightarrow{} Prop), \\
& \ \ (state \xrightarrow{} Prop) \xrightarrow{} \\ 
& \ \ (nat \xrightarrow{} state \xrightarrow{} Prop) \xrightarrow{} \\
& \ \ (\Pi (w : state), exists (v : state), trans\ w\ v)) \}).
\end{align*}

Построить терм типа $sts$ можно с помощью единственного конструктора $STS$. Аргументами конструктора являются:
\begin{enumerate}
    \item Тип $state$, термы которого являются состояниями этой модели Крипке. Множество термов соответствует множеству $S$  из раздела 2.1.
    \item Отображение $trans$, которое является отношением переходов $trans$ соответствует отношению $T$ из раздела 2.1.
    \item Третий аргумент -- это отображение $init$ из множества состояний в $Prop$. Этот аргумент был добавлен в конструктор для соответствия с моделью Крипке из раздела 2.1. И множество термов $t$, для которых можно доказать $init\ t$, соответствует множеству $S_0$ из раздела 2.1.
    \item Четвертый аргумент -- это отображение натурального числа, соответствующего элементу из множества атомарных высказываний, в предикат над множеством состояний. Соответствует функции разметки $L$ из раздела 2.1. 
    \item Пятый аргумент -- это доказательство тотальности построенной модели Крипке.
\end{enumerate}

Отображение, возвращающее тип состояний модели Крипке $M$, отвечает терму
\begin{align*}
&\lambda (M:sts).\\
& match\ M\ with \\
& |\ STS\ state\ trans\ init\ label\ serial \Rightarrow state \\
& end
\end{align*}

Обозначим это отображение как $state$.
Аналогично устроены термы, отвечающие отображениям, возвращающим отношение переходов ($trans$), множество начальных состояний модели ($init$), функцию разметки состояний ($label$), доказательство тотальности отношения переходов ($serial$).


\paragraph{Формализация оператора $AX$ в терминах \textit{CIC}}\mbox{}

Пусть контекстом задана модель Крипке типа $sts$, обозначенная переменной $H$.
Введем обозначения:
\begin{itemize}
    \item <<$Transition$>> обозначает $trans\ H$.
    \item <<$State$>> обозначает $state\ H$.
\end{itemize}

Терм (обозначим его через $cAX_{term}$), соответствующий оператору $AX$ из $CTL$, который имеет тип (обозначим его тип через $cAX_{type}$) 
$$(State \xrightarrow{} Prop) \xrightarrow{} State \xrightarrow{} Prop,$$
устроен так:
\begin{align*}
& \lambda (p : State \xrightarrow{} Prop). \\ 
& \lambda (w : State).\ \Pi (v : State), Transition\ w\ v \xrightarrow{}\ p\ v.
\end{align*}

Если отображение $f : State \xrightarrow{} Prop$ трактовать как множество состояний (всех термов $st$ типа $State$, для которых верно $(f\ st) : Prop$), то, как можно видеть по структуре терма и устройству определения операции $AX$ в разделе 2.1, возвращаемое отображение - это множество всех состояний модели, в которых выполняется формула $AX \phi$, если $p$ - множество всех состояний, в которых выполняется $\phi$.

Определим контекст $$\Gamma_{AX} = [cAX:=cAX_{term}:cAX_{type}].$$

\paragraph{Формализация пути в терминах \textit{CIC}}\mbox{} 

Терм (обозначим его через $path_{term}$), соответствующий определению пути из секции 2.1, который имеет тип (обозначим его тип через $path_{type}$) 
$$(nat \xrightarrow{} State) \xrightarrow{} Prop,$$
устроен так:
\begin{align*}
& \lambda (pi : nat \xrightarrow{} State).\\ 
& \Pi n : Nat, Transition\ (pi\ n) (pi\ (S\ n)).
\end{align*}

При подстановке отображения $pi$, означающего последовательность состояний, он возвращает тип. 
Терму этого типа отвечает отображение, которое ставит любому натуральному числу $n$ терм типа $Transition\ (pi\ n) (pi\ (S\ n))$ для $n$-ого и $(n+1)$-ого состояния последовательности $pi$.
Этот тип соответствует семантике определения пути из секции 2.1 согласно переходам модели Крипке.

Определим контекст $$\Gamma_{path} = [path:=path_{term}:path_{type}].$$

\paragraph{Формализация оператора $AU$ в терминах \textit{CIC}}\mbox{}

Терм (обозначим его через $AU_{term}$), соответствующий оператору $AU$ из $CTL$, который имеет тип (обозначим его тип через $AU_{type}$) 
$$ (State \xrightarrow{} Prop) \xrightarrow{} (State \xrightarrow{} Prop) \xrightarrow{} State \xrightarrow{} Prop,$$
устроен так:
\begin{align*}
&\lambda (p : State \xrightarrow{} Prop)(q : State \xrightarrow{} Prop). \\ & \lambda(w : State).\ \Pi (pi : nat \xrightarrow{} State), (path\ pi) \xrightarrow{} ((pi\ 0:State) = (w:State)) \xrightarrow{} \\ 
& exists2 (n : nat), (\Pi (m : nat), m < n \xrightarrow{} p\ (pi\ m))\ \&\ q\ (pi\ n).
\end{align*}

Если отображение $f : State \xrightarrow{} Prop$ трактовать как множество состояний (всех термов $st$ типа $State$, для которых верно $(f\ st) : Prop$), то, как можно видеть по структуре терма и устройству определения операции $AU$ в разделе 2.1, возвращаемое отображение - это множество всех состояний модели, в которых выполняется формула $\phi AU \psi$, если $p$ -- множество всех состояний, в которых выполняется $\phi$, a $q$ -- в которых выполняется $\psi$.
Действительно, возвращаемое множество состояний удовлетворяет суждению о том, что для каждого состояния $w$ этого множества и любого  исходящего из $w$ пути существует $n$-ое состояние пути на котором выполняется $q$, и на всех состояний с меньшим номером выполняется $p$.

Определим контекст $$\Gamma_{AU} = [pAU:=AU_{term}:AU_{type}].$$

\paragraph{Формализация оператора $AR$ в терминах \textit{CIC}}\mbox{}

Терм (обозначим его через $AR_{term}$), соответствующий оператору $AR$ из $CTL$, который имеет тип (обозначим его тип через $AR_{type}$) 
$$(State \xrightarrow{} Prop) \xrightarrow{} (State \xrightarrow{} Prop) \xrightarrow{} State \xrightarrow{} Prop,$$
устроен так:
\begin{align*}
& \lambda(p : State \xrightarrow{} Prop)(q : State \xrightarrow{} Prop).\\ 
& \lambda (w : X).\ \Pi (pi : nat \xrightarrow{} State), path\ pi \xrightarrow{} ((pi\ 0:State) = (w:State)) \xrightarrow{} \\
& \Pi (n : nat),(exists2\ m\ :\ nat, m < n\ \& \ p\ (pi\ m)) \lor q\ (pi\ n).
\end{align*}

Если отображение $f : State \xrightarrow{} Prop$ трактовать как множество состояний (всех термов $st$ типа $State$, для которых верно $(f\ st) : Prop$), то, как можно видеть по структуре терма и устройству определения операции $AR$ в разделе 2.1, возвращаемое отображение - это множество всех состояний модели, в которых выполняется формула $\phi AR \psi$, если $p$ -- множество всех состояний, в которых выполняется $\phi$, a $q$ -- в которых выполняется $\psi$.
Действительно, возвращаемое множество состояний удовлетворяет суждению о том, что для каждого состояния $w$ этого множества и любого исходящего из $w$ пути для любого $n$-ого состояния пути выполняется $q$, или существует состояние с меньшим номером, на котором выполняется $p$.

Определим контекст $$\Gamma_{AR} = [pAR:=AR_{term}:AR_{type}].$$

\paragraph{Формализация формулы \textit{CTL} в терминах \textit{CIC}}\mbox{} \\

Для удобства описания формулы используется индуктивный тип $form$
\begin{align*}
& ((form : Type), \{ \\ 
& \ \ (fF\ \ \ : form), \\
& \ \ (fV\ \ \ : nat \xrightarrow{} form), \\
& \ \ (fImp    : form \xrightarrow{} form \xrightarrow{} form), \\
& \ \ (fAnd    : form \xrightarrow{} form \xrightarrow{} form), \\
& \ \ (fOr\    : form \xrightarrow{} form \xrightarrow{} form), \\
& \ \ (fAX\    : form \xrightarrow{} form), \\
& \ \ (fAU\    : form \xrightarrow{} form \xrightarrow{} form), \\
& \ \ (fAR\    : form \xrightarrow{} form \xrightarrow{} form) \\
\}).
\end{align*}
Конструкторы $fF, fV, fImp, fAnd, fOr, fAX, fAU, fAR$ индуктивного типа $form$ отвечают операциям $false, p,\xrightarrow{}, \wedge, \vee, AX, AU, AR $.
% Конструкторы индуктивного типа $form$ соответствуют элементам укороченного синтаксиса формул $CTL$:
% \begin{itemize}
%     \item Конструктор $fF$ соответствует $false$.
%     \item Конструктор $fV$ соответствует $p$.
%     \item Конструктор $fImp$ соответствует $\xrightarrow{}$.
%     \item Конструктор $fAnd$ соответствует $\wedge$.
%     \item Конструктор $fOr$ соответствует $\vee$.
%     \item Конструктор $fAX$ соответствует $AX$.
%     \item Конструктор $fAU$ соответствует $AU$.
%     \item Конструктор $fAR$ соответствует $AR$.
% \end{itemize}
Термы типа $form$ естественным образом соответствуют формулам логики $CTL$.

\subsubsection{Постановка задачи проверки модели}
\paragraph{Преобразователь формулы в утверждение}\mbox{}

Терм, отвечающий отношению выполнимости формулы на модели, устроен так:
\begin{align*}
& fixpoint\ satisfies (M : sts) (s : form)\{struct\ s\}: (state\ M) \xrightarrow{} Prop := \\
&\  (match\ s\ with \\
&\ |\ fF \ \ \ \ \ \ \ \     \Rightarrow \lambda (w : state\ M).\ False\\
&\ |\ fV\ v \ \ \ \ \    \Rightarrow \lambda (w : state\ M).\ label\ M\ v\ w \\
&\ |\ fImp\ p\ q \Rightarrow \lambda (w : state\ M).\ (satisfies\ M\ p\ w \xrightarrow{} satisfies\ M\ q\ w) \\
&\ |\ fAnd\ p\ q \Rightarrow \lambda (w : state\ M).\ (satisfies\ M\ p\ w \wedge satisfies\ M\ q\ w) \\
&\ |\ fOr\ p\ q \ \ \Rightarrow \lambda (w : state\ M).\ (satisfies\ M\ p\ w \vee satisfies\ M\ q\ w) \\
&\ |\ fAX\ p \ \ \   \Rightarrow \lambda (w : state\ M).\ cAX (satisfies\ M\ p)\ w \\
&\ |\ fAR\ p\ q \ \Rightarrow \lambda (w : state\ M).\ pAR (satisfies\ M\ p) (satisfies\ M\ q)\ w \\
&\ |\ fAU\ p\ q \ \Rightarrow \lambda (w : state\ M).\ pAU (satisfies\ M\ p) (satisfies\ M\ q)\ w \\
&\ end: (state\ M) \xrightarrow{} Prop ).
\end{align*}

Обозначим этот терм через $sat_{term}$. 
Соответствующее отображение принимает на вход терм типа $sts$, соответствующий модели Крипке, и терм типа $form$, соответствующий формуле \textit{CTL}, и возвращает предикат, который строится следующим образом: структура терма типа $form$ отвечает способу задания семантики формулы в разделе 2.1, структура подттерма $match$ отвечает пунктам задания семантики формул соответствующего оператора, и надтерм $fixpoint$ используется для индуктивного (рекурсивного) задания семантики в этих пунктах.

Определим контекст 
$$\Gamma_{satisfies}=[satisfies:=sat_{term}:\Pi(M : sts), form \xrightarrow{} (state\ M) \xrightarrow{} Prop].$$

\paragraph{Постановка задачи проверки модели}\mbox{}

Пусть заданы контексты 
$$\Gamma_{model} = [model:=model_{term}:sts],$$ 
$$\Gamma_{formula} = [ formula :=formula_{term}:form],$$ где $model_{term}$,$formula_{term}$ -- это термы, описывающие соответственно модель и формулу, для которых нужно проверить отношение выполнимости.
 
\textbf{Задача проверки модели для логики \textit{CTL} в терминах исчисления индуктивных конструкций -- это проверка выводимости суждения о типе}

$$\Gamma_{MC} \vdash t: Sat,$$
где
$\Gamma_{MC}=\Gamma_{eq} \cup \Gamma_{or} \cup \Gamma_{and} \cup \Gamma_{ex} \cup \Gamma_{ex2} \cup \Gamma_{sts} \cup \Gamma_{form}\cup \Gamma_{model} \cup \Gamma_{formula} \cup \Gamma_{AR} \cup \Gamma_{AU} \cup \Gamma_{AX} \cup \Gamma_{satisfies}$,
$Sat= \Pi (st:\ state\ model), ((init\ model)\ st) \xrightarrow{} (satisfies\ model\ formula\ st).$

% Выводимость суждение о типе $\Gamma \vdash t: Sat$ отвечает случаю, когда формула выполняется на модели, а для случая, когда формула невыполнима, аналогичная задача будет сформулирована позже.

\subsection{Синтаксис и семантика языка тактик \textit{Ltac}.}

В \textit{Coq} доступны средства для создания собственных тактик, которые можно применять для доказательства теорем. Одним из таких средств является язык тактик \textit{Ltac}. 

В работе \cite{LtacFull}, посвященной  полному описанию синтаксиса и семантики, используемый математический аппарат является затруднительным для использования в данной работе. Документация же по языку \textit{Ltac} \cite{lib} дает лишь не вполне строгое описание синтаксиса и семантики.

В данном разделе представлено описание части синтаксиса и семантики языка \textit{Ltac}, потребовавшейся для решения задачи проверки модели в терминах исчисления индуктивных конструкций.

Часть синтаксиса  языка тактик \textit{Ltac} над множеством базовый тактик \textit{Tactic}, множеством имен \textit{Name}, множеством термов \textit{term} можно задать следующей БНФ:

\makeatletter
\def\verbatim@font{\linespread{1}\normalfont\ttfamily}
\makeatother
\begin{verbatim}
ltac_expr         ::=    ltac_expr ; ltac_expr
                       | [> ltac_expr | ... | ltac_expr ]
                       | (progress ltac_expr)
                       | (repeat ltac_expr)
                       | (try ltac_expr)
                       | let name in ltac_expr
                       | let name parameters := ltac_expr in ltac_expr
                       | (ltac_expr + ltac_expr)
                       | (tryif ltac_expr then ltac_expr else ltac_expr)
                       | (solve [ ltac_expr ])
                       | fail
                       | idtac
                       | tactic
                       | lazymatch type of name with 
                         | term => ltac_expr 
                         ...
                         | term => ltac_expr
                         | name    => ltac_expr
                         end
                       | lazymatch goal with 
                         | term => ltac_expr 
                         ...
                         | term => ltac_expr
                         | name    => ltac_expr
                         end
                       | lazymatch term with 
                         | term => ltac_expr 
                         ...
                         | term => ltac_expr
                         | name    => ltac_expr
                         end
                        
\end{verbatim}
где \verb|tactic|$\ \in Tactic$, \verb|name|$\ \in Name$, \verb|term|$\ \in term$, \verb|ltac_expr| - $Ltac$-выражение построенное на языке \textit{Ltac},
\verb|parameters|- набор параметров, где каждый параметр из множества $Tactic \bigcup Name \bigcup term \bigcup L$, где $L$ -- множество всех $Ltac$-выражений.


% Состояние доказательства -- это пара, состоящая из цели и оценки параметров. Состояние вычисления — это пара $(l, s)$, где $l$ — состояние управления, а $s$ — состояние данных.
Связкой назовём запись $a/l$, где $a \in Name, l\in Tactic \bigcup Name \bigcup term \bigcup L$, и для такой связки будем называть $l$ значением параметра $a$.
Оценкой параметров назовём конечное множество связок $[a_1/l_1,...,a_n/l_n]$, в котором каждый параметр $a_1,...a_n \in Name$ в оценке параметров отлично от других имен в этой оценке, и имен базовых тактик.
Запись $\Gamma \vdash A,$ где $\Gamma$ -- это контекст, $A$ -- тип, будем называть целью. Цель $\Gamma \vdash A$ означает, что есть терм $t$ типа $A$, для которого верно $\Gamma \vdash t: A$. 
Состоянием доказательства будем называть пару $((\Gamma \vdash A),\theta)$, где первый элемент -- это цель, а второй -- оценка параметров $\theta = [a_1/l_1, ..., a_n/l_n]$. Будем обозначать тот факт, что существует связка с параметром $a_i$ значением $l_i$ в оценке $\theta$, записью вида $a_i/l_i \in \theta$.

Состояние управление — это  $Ltac$-выражение. Состояние вычисления — это пара $(l | g)$, где $l$ — состояние управления, а $g$ — упорядоченный набор состояний доказательства.

Определим отношение переходов $\xrightarrow{}$ на множестве состояний вычисления для $Ltac$-выражения $l$.
Будем писать $S_1 \Rightarrow S_2$ для состояний вычисления $S_1$, $S_2$ в том случае, если существует последовательность $S_1 \xrightarrow{} ... \xrightarrow{} S_2$.
Пусть $l_1$,$l_2$ -- $Ltac$-выражения, $g$ -- набор состояний доказательства. Состояние ошибки -- $\bot$.

\begin{enumerate}
    \item[1.] Если  $(l_i|(g_i)) \Rightarrow (idtac|(h_i)), \forall i = 1,...,n$, то $([>l_1|..|l_n]|(g_1,...,g_n)) \xrightarrow{} (idtac|(h_1,..,h_n))$
    \item[  ] Если $\exists i=1,...,n$, $(l_i, (g_i)) \Rightarrow \bot$, $([>l_1|..|l_n]|(g_1,...,g_n)) \xrightarrow{} \bot$
    \item[2.] Если $(l_1|g_1) \Rightarrow (idtac|g_2)$, то $(l_1;l_2|g_1) \xrightarrow{} ([>l_2|...|l_2]|g_2)$.
    \item[  ] Если $(l_1|g_1) \Rightarrow \bot$, то $(l_1;l_2|g_1) \xrightarrow{} \bot$.
    % Если $(l_1|g_1) \Rightarrow (idtac|g_2)$, то $(l_1;l_2|g_1) \xrightarrow{} (l_2|g_2)$.
    % 2.  (idtac|g) -> (пусто|g).
    \item[3.] Если $(l_1|g_1) \Rightarrow (idtac|g_1)$ или $(l_1|g_1) \Rightarrow \bot$, то $(repeat l_1|g_1) \xrightarrow{} (idtac|g_1)$.
    \item[  ] Если $(l_1|g_1) \Rightarrow (idtac|g_2)$, где $g_1 \neq g_2$, то $(repeat\ l_1|g_1) \xrightarrow{} (repeat l_1|g_2)$.
    
    \item[4.] Если $(l_1|g_1) \Rightarrow (l_2|g_2)$, то
    $((try\ l_1)| g_1) \xrightarrow{} ((try\ l_2)| g_2)$
    \item[]   Если $(l_1|g_1) \Rightarrow{} \bot$, то
    $((try\ l_1)| g_1) \Rightarrow{} (idtac| g_1)$
    
    \item[5.] Пусть $g_1 = ((h_{1}, \theta_1), ..., (h_{m}, \theta_m))$, тогда 
    $(let\ name\ in\ l|g_1) \xrightarrow{} (l|(h_{1}, k_1), ..., (h_{m}, k_m))$, где $k_i$ получается из $\theta_i=[a_0/f_0,...,a_s/f_s]$ следующим образом: 
    \item[]   если $\exists j, name = a_j$, 
    то $k_i = [a_0/f_0,...,a_j/name_{s+1},..., a_s/f_s]$, 
    \item[]   если $\forall j,name \neq a_j$, 
    то $k_i = [a_0/f_0, a_s/f_s, name/name_{s+1}]$, 
    \item[]   где $name_{s+1} \in Name$ новое уникальное имя, которое не было использовано
    \item[6.] Пусть $g_1 = ((h_{1}, \theta_1), ..., (h_{m}, \theta_m))$, тогда 
    $(let\ rec\ name\ p_1,...,p_n\ := l_1 in\ l_2|g_1) \xrightarrow{} (l_2|(h_{1}, k_1), ..., (h_{m}, k_m))$, где $k_i$ получается из $\theta_i=[a_0/f_0,..., a_s/f_s]$ следующим образом: 
    \item[]   если $\exists j, name = a_j$, 
    то $k_i = [a_0/f_0,...,a_j/l_1(p_1,...,p_n),..., a_s/f_s]$, 
    \item[]   если $\forall j,name \neq a_j$, 
    то $k_i = [a_0/f_0, a_s/f_s, name/(l_1\ p_1,...,p_n)]$, 
    \item[]   где $p_1,...,p_n, p_i \in term \bigcup Name \bigcup Tactic \bigcup L$ -- это параметры $l_1$.

    
    \item[7.] Если $(l_1|g_1) \Rightarrow (l_2|g_2)$, то
    $(tryif\ l_1\ then\ a\ else\ b|g_1) \xrightarrow{} (tryif\ l_2\ then\ a\ else\ b|g_2)$
    \item[]   Если $(l_1|g_1) \Rightarrow (idtac|g_2)$, то
    $(tryif\ l_1\ then\ a\ else\ b|g_1) \xrightarrow{} (a|g_2)$
    \item[]   Если $(l_1|g_1) \Rightarrow \bot$, то
    $(tryif\ l_1\ then\ a\ else\ b|g_1) \xrightarrow{} (b|g_2)$
    \item[8.] $(a+b,g) \xrightarrow{} (tryif\ a\ then\ idtac\ else\ b| g)$
    \item[9.] Если $(l_1|g_1) \Rightarrow (l_2|g_2)$, то
    $((solve\ l_1)|g_1) \xrightarrow{} ((solve\ l_2)|g_2)$
    \item[]   Если $(l_1|g_1) \Rightarrow{} (idtac|g_2)$ и $g_2 = ((\Gamma_1 \vdash, \theta_1),...,(\Gamma_s \vdash, \theta_s))$ то
    $((solve\ l_1)|g_1) \xrightarrow{} (idtac|g_2)$
    \item[]   Если $(l_1|g_1) \Rightarrow{} (idtac|g_2)$ и $g_2 \neq ((\Gamma_1 \vdash, \theta_1),...,(\Gamma_s \vdash, \theta_s))$ то
    $((solve\ l_1)|g_1) \xrightarrow{} \bot$

    \item[10.] $(fail|g) \xrightarrow{} \bot $
    \item[11.] Рассмотрим $Ltac$-выражение 
    \begin{align*}
    & lazymatch\ type\ of\ name\ with \\
    & |\ term_1 (x_{1_1}, ..., x_{1_m}) \Rightarrow l_1\\
    & \ ... \\
    & |\ term_n (x_{n_1}, ..., x_{n_m}) \Rightarrow l_n \\
    & |\ x \Rightarrow l_{n+1} \\
    & end \\
    \end{align*}
    
    Пусть $g=(g_1,...,g_n),$ где $$g_i=((\Gamma_i, name_i: \hat{term_i}(y_{i_1}, ..., y_{i_m}) \vdash A_i), [a_{i1}/f_{i1},..., name/name_i,...,a_{im}/f_{im}])$$
    Тогда 
    \begin{align*}(
    & lazymatch\ type\ of\ name\ with \\
    & |\ term_1(x_{1_1}, ..., x_{1_m}) \Rightarrow l_1\\
    & \ ... \\
    & |\ term_n(x_{n_1}, ..., x_{n_m}) \Rightarrow l_s \\
    & |\ x \Rightarrow l_{s+1} \\
    & end | g)\\
    \end{align*}
    $$\xrightarrow{} ([o_1|...| o_{n}]|h),$$ где $o_i, i=1,...,n$ и $h=(h_1,...,h_n)$ строятся следующим образом:
    \item[] Для каждого терма $term_{j}$, если $term_{j}$ является уточнением терма $\hat{term_{i}}$, то $o_i=l_j$ и 
    $$h_i=((\Gamma_i, name_i: \hat{term_i}(y_{i_1}, ..., y_{i_m}) \vdash A_i),$$ $$ [a_{i1}/f_{i1},..., name/name_i,...,a_{im}/f_{im}, x_{i_1}/y_{i_1},..., x_{i_m}/y_{i_m}])$$
    \item[] Если $\exists i,j, i \neq j:$ $term_i$ и $term_j$ одновременно являются уточнением для какого-то терма, то выбирается индекс с меньшим номером
    \item[] Если $\forall j, term_j$ не является уточнением терма $\hat{term_i}$, то $o_i=l_{s+1}$ и $$h_i=((\Gamma_i, name_i: \hat{term_i}(y_{i_1}, ..., y_{i_m}) \vdash A_i),$$ $$ [a_{i1}/f_{i1},..., name/name_i,...,a_{im}/f_{im}, x/\hat{term_i}(y_{i_1}, ..., y_{i_m}))$$

    Таким же образом работает тактика $lazymath\ goal\ with...$ и $lazymath\ term\ with...$, только в этом случае, термы сопоставляются с целью текущего состояния доказательства и термами, соответственно. 
    
\end{enumerate}

Вычислением тактики $l$ на наборе состояний доказательства $(g_1,...,g_n)$ будем называть последовательность состояний вычислений, в которой соседние состояния соединены отношением $\xrightarrow{}$ и последнее состояние, если оно есть, - это $(idtac|h)$, где $h$ -- некоторый набор состояний доказательства. Будем говорить, что тактика $l$ строит успешный вывод для набора состояний доказательства, если вычисление этой тактики не содержит состояния ошибки и последнее состояние имеет следующий вид $(idtac|h)$, где $h=(h_1,...,h_m)$, $h_i= ((\Gamma_i \vdash),\theta_i),i=1,...,m$.
% // видимо, следует включить пустую тактику (idtac) в язык, чтобы сказать, что оканчивается либо ошибкой, либо этим выражением
% Будем говорить, что $Ltac$-выражение l строит успешный вывод, если вычисление $solve[l]$ не приводит к ошибке ($\bot$).

\subsection{Синтаксис и семантика базовых тактик}
\paragraph{split.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma_i \vdash A_i \wedge B_i), \theta_i)$.
Тактика \textit{split} действует следующим образом:
$$(split|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1,\hat{h_1},h_2,\hat{h_2},...,h_n,\hat{h_n}),$ где $h_i= ((\Gamma \vdash A_i), \theta_i)$ и $\hat{h_i}= ((\Gamma \vdash B_i), \theta_i).$
Если $\exists i$ такой, что цель в состоянии доказательства $g_i$ не является типом $and$, то
$$(split|g) \xrightarrow{} \bot.$$

\paragraph{intro.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma_i \vdash \Pi (x:A_i)), B_i), \theta_i), H/\alpha \in \theta_i$.
Тактика \textit{intro} действует следующим образом:
$$(intro\ H|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1,...,h_n),$ где $h_i= ((\Gamma, \alpha:A_i \vdash B_i\{x/\alpha\}), \theta_i).$
Если $\exists i$ такой, что цель в состоянии доказательства $g_i$ не является типом вида $\Pi (x:A), B$, то
$$(intro\ H|g) \xrightarrow{} \bot.$$

\paragraph{rewrite.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma, (\alpha: A_i = B_i) \vdash C_i), \theta_i)$, $H/\alpha \in \theta_i$.
Если $A_i$ свободно входит в тип $C_i$, то тактика \textit{rewrite H} действует следующим образом:

$$(rewrite\ H|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1,...,h_n),$ где $h_i= (\Gamma, (\alpha: A_i = B_i) \vdash C_i\{A_i/B_i\}), \theta_i), H/\alpha \in \theta_i$ иначе
$$(rewrite\ H|g) \xrightarrow{} \bot.$$

Пусть $g_i = ((\Gamma, (\alpha: A_i = B_i),(\beta: D_i) \vdash C_i), \theta_i)$, $H_1/\alpha \in \theta_i, H_2/\beta \in \theta_i$.
\begin{enumerate}
    \item[1.] Если $A_i$ свободно входит в тип $D_i$, то тактика $rewrite\ H_1\ in\ H_2$ действует следующим образом:
    $$(rewrite\ H_1\ in\ H_2|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1,...,h_n),$ где $h_i= (\Gamma, (\alpha: A_i = B_i), (\beta: D_i\{A_i/B_i\}) \vdash C_i), \theta_i),$ иначе
    $$(rewrite\ H_1\ in\ H_2|g) \xrightarrow{} \bot.$$
    \item[2.] Если $B_i$ свободно входит в тип $D_i$, то тактика $rewrite\ \xleftarrow{} H_1\ in\ H_2$ действует следующим образом:
    $$(rewrite\ \xleftarrow{} H_1\ in\ H_2|g) \xrightarrow{} (idtac| h),$$
    где $h=(h_1,...,h_n),$ где $h_i= ((\Gamma, (\alpha: A_i = B_i), (\beta: D_i\{B_i/A_i\}) \vdash C_i), \theta_i),$  
    иначе
    $$(rewrite\ \xleftarrow{} H_1\ in\ H_2|g) \xrightarrow{} \bot.$$
\end{enumerate}


\paragraph{left и right.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma \vdash A_i \vee B_i), \theta_i)$.
Тактика \textit{left} действует следующим образом:
$$(left|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1, ...,h_n),$ где $h_i= ((\Gamma_i \vdash A_i), \theta_i)$.

Тактика \textit{right} действует следующим образом:
$$(right|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1, ...,h_n),$ где $h_i= ((\Gamma_i \vdash B_i), \theta_i)$.
Если $\exists i$ такой, что цель в состоянии доказательства $g_i$ не является типом $or$, то
$$(left|g) \xrightarrow{} \bot,$$ 
$$(right|g) \xrightarrow{} \bot.$$ 


\paragraph{lia.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma \vdash B_i), \theta_i)$, где тип $B_i$ является арфиметическим выражением, то есть тип построенный с помощью типов $Nat$, $eq$, $le$ и других типов, отвечающих арифметическим и булевым операциям и отношениям.
Тактика \textit{lia} действует следующим образом:
$$(lia|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1, ...,h_n),$ где $h_i= ((\Gamma_i \vdash), \theta_i)$. Если цель в состояниях $g_i$ невозможно доказать, то
$$(lia|g) \xrightarrow{} \bot.$$

\paragraph{discriminate.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma, (H: a = b) \vdash B_i), \theta_i)$, где тип $B_i$ произвольная цель, $a$ и $b$ -- это два неодинаковых конструктора одно и того же какого-то индуктивного типа.
Тактика \textit{discriminate} действует следующим образом:
$$(discriminate|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1, ...,h_n),$ где $h_i= (\Gamma_i \vdash , \theta_i)$.
Если в текущем контексте не представлена гипотеза вида $(H:a=b)$, то 
$$(discriminate|g) \xrightarrow{} \bot.$$

\paragraph{compute.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma \vdash B_i), \theta_i)$,
Тактика \textit{compute} действует следующим образом:
$$(compute|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1, ...,h_n),$ где $h_i= (\Gamma_i \vdash  С_i , \theta_i),$, где $C_i$ получается из $B_i$ применением $\beta$ и $\iota$ редукций.

Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma, (\alpha: A_i) \vdash B_i), \theta_i)$, $H/\alpha \in \theta_i$.
Тактика \textit{compute} действует следующим образом:
$$(compute\ in\ H|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1, ...,h_n),$ где $h_i= ((\Gamma, (\alpha: C_i) \vdash B_i ), \theta_i),$ где $C_i$ получается из $A_i$ применением $\beta$ и $\iota$ редукций.

\paragraph{destruct.}

\begin{enumerate}
    \item[1.] Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma, (\alpha:A_i \vee B_i) \vdash C_i ), \theta_i)$, $H/\alpha \in \theta_i$.
    Тактика \textit{destruct H as [H | H]} действует следующим образом:
$$(destruct\ H\ as\ [H\ |\ H]|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1,h_2,...,h_n,\hat{h_1},\hat{h_2},...,\hat{h_n}),$ где $h_i= ((\Gamma, (\alpha:A_i) \vdash C_i), \theta_i)$ и $\hat{h_i}= ((\Gamma, (\alpha: B_i) \vdash C_i), \theta_i).$
Если $\exists i$ такой, что гипотеза $\alpha$ в состоянии доказательства не имеет тип $or$, то
$$(destruct\ H\ as\ [H\ |\ H]|g) \xrightarrow{} \bot.$$
    \item[2.] Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma, (\alpha: A_i \wedge B_i) \vdash C_i ), \theta_i)$, $H/\alpha,a/\beta,b/\gamma \in \theta_i$.
    Тактика \textit{destruct H as (a $\&$ b)} действует следующим образом:
    $$(destruct\ H\ as\ (a \& b)|g) \xrightarrow{} (idtac| h),$$
    где $h=(h_1,h_2,...,h_n),$ где $h_i= ((\Gamma, (\beta:A_i), (\gamma:B_i) \vdash C_i), \theta_i)$
    Если $\exists i$ такой, что гипотеза $\alpha$ в состоянии доказательства не имеет тип $and$, то
$$(destruct\ H\ as\ (a \& b)|g) \xrightarrow{} \bot.$$
    \item[3.] Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma, (\alpha:A) \vdash C_i ), \theta_i)$, $H/\alpha \in \theta_i$, где $A$--индуктивный тип. Тактика \textit{destruct H} действует следующим образом:
    $$(destruct\ H|g) \xrightarrow{} (idtac| h),$$
    где $h$ равен конкатенации наборов $G_i$, $G_i =(g_{i1}, ..., g_{in})$, где $g_{is}$ получается из $g_i$ следующим образом:
    каждое вхождение гипотезы $\alpha$ в типы остальных гипотез заменяется на $s$-ый конструктор индуктивного типа $A$, иначе если $A$ не является индуктивным типом, то
    $$(destruct\ H|g) \xrightarrow{} \bot.$$
\end{enumerate}

\paragraph{apply.}

Пусть $g_i = ((\Gamma, (\alpha:  D_i \xrightarrow{} B_i) (\beta: C_i) \vdash D_i), \theta_i)$, $H_1/\alpha H_2/\beta \in \theta_i$, $D_i = C_i$.
Тактика $apply\ H_1\ in\ H_2$ действует следующим образом:
$$(apply\ H_1\ in\ H_2|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1,h_2,...,h_n),$ где $h_i= ((\Gamma, (\alpha:  D_i \xrightarrow{} B_i) (\beta: B_i) \vdash D_i), \theta_i)$,
если $D_i \neq C_i,$ то
$$(apply\ H_1\ in\ H_2|g) \xrightarrow{} \bot.$$

Пусть $g_i = ((\Gamma, (\alpha:  D_i) \vdash C_i), \theta_i)$, $H/\alpha \in \theta_i$, $D_i = C_i$.
Тактика $apply\ H$ действует следующим образом:
$$(apply\ H_1\ in\ H_2|g) \xrightarrow{} (idtac| h),$$
где $h=(h_1,h_2,...,h_n),$ где $h_i= ((\Gamma, (\alpha:  D_i) \vdash), \theta_i)$,
если $D_i \neq C_i,$ то
$$(apply\ H_1\ in\ H_2|g) \xrightarrow{} \bot.$$

\paragraph{pose proof.}

Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma_i \vdash C_i), \theta_i)$, $H/\alpha \in \theta_i$.
Тактика \textit{pose proof ($t:A$) as H}  действует следующим образом:
$$(pose\ proof\ (t:A)\ as\ H|g) \xrightarrow{} (idtac| h),$$ 
где $h=(h_1,h_2,...,h_n),\ h_i= ((\Gamma_i, (\alpha: A) \vdash C_i), \theta_i),$где $t$-- корректно построенный в контексте $\Gamma_i$ терм типа $A$&

\paragraph{eexists.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma_i \vdash exists2 (k : A), B_i \& C_i), \theta_i)$.
Тактика \textit{eexists t}  действует следующим образом:
$$(eexists\ t|g) \xrightarrow{} (idtac| h),$$ 
где $h=(h_1, \hat{h_1}, h_2,\hat{h_2},...,h_n,\hat{h_n}),$ где $h_i= ((\Gamma_i \vdash B_i\{k/t\}), \theta_i)$ и $\hat{h_i}= ((\Gamma_i \vdash C_i\{k/t\}), \theta_i)$, где $t$-- корректно построенный в контексте $\Gamma_i$ терм типа $A$.

\paragraph{assert.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma_i \vdash B_i), \theta_i)$.
Тактика \textit{assert (A)}  действует следующим образом:
$$(assert (A)|g) \xrightarrow{} (idtac| h),$$ 
где $h=(\hat{g_1},g_1,\hat{g_2},g_2,...,\hat{g_2},g_n), \hat{g_i} = ((\Gamma_i \vdash A), \theta_i)$, где $A$-- корректно построенный тип в контексте $\Gamma_i$ .

Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma_i, (\beta:A_i) \vdash B_i), \theta_i), H_1/\alpha, H_2/\beta \in \theta_i$ .
Тактика \textit{assert ($H_1:=H_2$)}  действует следующим образом:
$$(assert (H_1:=H_2)|g) \xrightarrow{} (idtac| h),$$ 
где $h=(h_1,h_2,...,h_n),$ где $h_i= ((\Gamma_i, (\beta: A_i),(\alpha: A_i) \vdash C_i), \theta_i)$.


Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma_i \vdash B_i), \theta_i), H/\alpha$.
Тактика \textit{assert ($H$: A)}  действует следующим образом:
$$(assert (H:A)|g) \xrightarrow{} (idtac| h),$$ 
где $h=(h_1,\hat{g_1},g_2,\hat{g_2},...,h_n,\hat{g_n}), \hat{g_i} = ((\Gamma_i, (\alpha:A) \vdash B_i), \theta_i)$,${h_i} = ((\Gamma_i \vdash A), \theta_i)$, где $A$-- корректно построенный тип в контексте $\Gamma_i$ .

\paragraph{reflexivity.}
Пусть $g = (g_1, ..., g_n)$, где $g_i = ((\Gamma_i \vdash B_i=B_i), \theta_i)$.
Тактика \textit{reflexivity}  действует следующим образом:
$$(reflexivity|g) \xrightarrow{} (idtac| h),$$ 
где $h=(h_1, ...,h_n),$ где $h_i= ((\Gamma_i \vdash), \theta_i)$.
Если цель в состояниях доказательства не является индуктивным типом $eq$, то 
$$(reflexivity|g) \xrightarrow{} \bot.$$ 

\subsection{Ограничения на представление модели Крипке}



% чего-то выделял и выделял дальше - и понял, что давайте-ка я подскажу, как это изложить более систематично.

В типе $sts$ моделей Крипке не накладывается требование конечности множества состояний модели, обычное для моделей Крипке и содержащееся в определении в разделе 2.1.
Чтобы соблюсти это требование и конкретизировать тип моделей Крипке, будем считать, что состояния модели задаются индуктивным типом $((A : Type), \{(constr_1 : A), ..., (constr_n : A)\})$, то есть состояниями являются термы $constr_1$, ..., $constr_n$ и только они.
% // не переназвать ли тогда это всё для наглядности? например, тип S и термы s_1, ..., s_n

Для представления отношения переходов введём вспомогательные индуктивные типы $prod$ и $list$, которые соответственно описывают пары и списки термов:
$$(prod (A:Type) (B:Type):Type, \{ pair:A\ \xrightarrow{} B \xrightarrow{} (prod\ A\ B)\}),$$
$$(list (A : Type) : Type, \{ nil : list\ A, cons : A \xrightarrow{} list\ A \xrightarrow{} list\ A \}).$$

Множество переходов модели Крипке представим в виде списка смежности - списка пар вида $(r_0, (r_1, ..., r_k))$ с попарно различными элементами $r_0$, где $r_0$ - состояние, из которого исходит переход, а $r_1, ..., r_k$ - все состояния, в которые ведут переходы из$ r_0$.
Таким образом, список смежности для переходов модели Крипке задаётся термом типа $list\ (prod\ A\ (list\ A))$.

Отношение переходов модели Крипке, основанное на списке смежности $l$, задаётся термом $(\lambda (s_1:A), \lambda (s_2:A), make\_prop\ s_1\ s_2\ t)$ типа $A \xrightarrow{} A \xrightarrow{} Prop$, где
\begin{align*}
& fixpoint\ make\_dis(A:Type) (s_2:A)(states\_in: list A)\{struct states\_in\}: Prop := \\
&\  (match\ states\_in\ with \\
&\ |\ cons\ head\ nil \Rightarrow eq\ s_2\ head \\
&\ |\ cons\ head\ tail  \Rightarrow or (eq\ s_2\ head) (make\_dis\ A\ s_2\ tail) \\
&\ |\ nil \Rightarrow False \\
&\ end: \Pi( A : Type), A \xrightarrow{} list A \xrightarrow{} Prop),
\end{align*}

\begin{align*}
& fixpoint\ make\_prop(A:Type)(B:Type) (s_1:A)(s_2:B)\\ 
& (list\_conn: list (prod\ A\ (list\ B))) \{struct\ list\_conn\}: Prop := \\
&\  (match\ list\_conn\ with \\
&\ |\ cons\ (pair\ b_1\ b_2)\ nil => ((eq\ s_1\ b_1) \xrightarrow{} (make\_dis\ s_2\ b_2)) \\
&\ |\ cons\ (pair\ b_1\ b_2)\ tail  \Rightarrow and ((eq\ s_1\ b_1) \xrightarrow{} (make\_dis\ s_2\ b_2)) (make\_prop\ s_1\ s_2\ tail) \\
&\ |\ nil \Rightarrow False \\
&\ end: \Pi (A : Type), A \xrightarrow{} list A \xrightarrow{} Prop).
\end{align*}

С поправкой на бета и йота редукцию, этот терм можно записать в виде
$$(\lambda (s_1:A), \lambda (s_2:A), (s_1=constr_1 \xrightarrow{} (s_2=constr_{11} \vee ... \vee s_2=constr_{1m})) \wedge ... $$
$$... \wedge (s_1=constr_n \xrightarrow{} (s_2=constr_{n1} \vee ... \vee s_2=constr_{nm}))$$
явного перечисления всех дуг $(constr_i, constr_{ij})$.

Аналогично можно задать список $l$ пар $(r_0, (i_1, ..., i_s))$  с попарно различными элементами $r_0$, где $r_0$ - состояние, а $i_1,...,i_s$ термы типа $Nat$, соответствующие переменным $x_{i_1},...,x_{i_n}$, и терм $(\lambda (a:nat), \lambda  (b:A), make\_prop\ b\ a\ l)$ типа $Nat \xrightarrow{} A \xrightarrow{} Prop$, с поправкой на $\beta$ и $\iota$ редукцию записывающийся в виде 
$$(b=constr_1 \xrightarrow{} (a=k_{11} \vee ... \vee a=k_{1m})) \wedge ... $$
$$... \wedge (b=constr_n \xrightarrow{} (a=k_{n1} \vee ... \vee a=k_{nm}))$$
% ...
и естественно задающий функцию разметки модели Крипке, согласно которой состояние $constr_i$ помечено множеством атомарных высказываний $\{x_{k_{i1}},...,x_{k_{im}}\}$.

Для технической простоты будем рассматривать только модели с одним начальным состоянием, и тот факт, что состояние $v$ является начальным, будем обозначать термом $(\lambda (s:A),\ eq\ s\ v)$ типа $ A \xrightarrow{} Prop$ .

На способ записи доказательства тотальности отношения переходов в типе $sts$ не будем накладывать никаких ограничений.


% Терм индуктивного типа $sts$, изложенный в параграфе 4.1.2 позволяет описать термы соответствующием моделям Крипке с неограниченным числом состояний, поэтому далее будем рассматривать для создания терма типа $sts$ индуктивные типы $A$, которые имеют конечное число термов и имеют $n$ конструкторов вида $constr_1:A$,...,$constr_n:A$. 

% Введем ограничение на представление отношения преходов для рассматриваемых моделей Крипке.

% Введем вспомогательные индуктивные типы $prod$ и $list$, которые соответственно описывают пары и списки термов:
% $$(prod (A:Type) (B:Type):Type, \{ pair:A\ \xrightarrow{} B \xrightarrow{} (prod\ A\ B)\}),$$
% $$(list (A : Type) : Type, \{ nil : list\ A, cons : A \xrightarrow{} list\ A \xrightarrow{} list\ A \}).$$

% Для задания отношения перехода представим модель Крипке как ориентированный граф $G = (V, E)$, в $V$--множество термов состояний, $E$--множество пар термов $(t_1,t_2)$, которые находятся в отношении перехода. Одним из представлений ориентированных графов является список смежности. Список смежности -- это список пар, где первый элемент вершина, из которой исходит дуга, и где второй элемент, список вершин куда входит дуга. Введем ограничение, что список смежности должен содержать каждый конструктор ровно один раз как первый элемент пары. Пусть задан индуктивный тип $A$, термы которого описывают состояния модели Крипке, пусть задан терм $t$ типа $list (prod A (list A))$, описывающий список смежности графа модели Крипке.

% Введем вспомогательные термы для преобразования списка смежности в терм, необходимого для задания модели Крипке.

% \begin{align*}
% & fixpoint\ make\_dis(A:Type) (s_2:A)(states\_in: list A)\{struct states\_in\}: Prop := \\
% &\  (match\ states\_in\ with \\
% &\ |\ cons\ head\ nil \Rightarrow eq\ s_2\ head \\
% &\ |\ cons\ head\ tail  \Rightarrow or (eq\ s_2\ head) (make\_dis\ A\ s_2\ tail) \\
% &\ |\ nil \Rightarrow False \\
% &\ end: \Pi( A : Type), A \xrightarrow{} list A \xrightarrow{} Prop).
% \end{align*}

% \begin{align*}
% & fixpoint\ make\_prop(A:Type)(B:Type) (s_1:A)(s_2:B)\\ 
% & (list\_conn: list (prod\ A\ (list\ B))) \{struct\ list\_conn\}: Prop := \\
% &\  (match\ list\_conn\ with \\
% &\ |\ cons\ (pair\ b_1\ b_2)\ nil => ((eq\ s_1\ b_1) \xrightarrow{} (make\_dis\ s_2\ b_2)) \\
% &\ |\ cons\ (pair\ b_1\ b_2)\ tail  \Rightarrow and ((eq\ s_1\ b_1) \xrightarrow{} (make\_dis\ s_2\ b_2)) (make\_prop\ s_1\ s_2\ tail) \\
% &\ |\ nil \Rightarrow False \\
% &\ end: \Pi (A : Type), A \xrightarrow{} list A \xrightarrow{} Prop).
% \end{align*}

% Таким образом, для описания отношения перехода при создании терма модели Крипке будем использовать следующий терм
% $$(\lambda (s_1:A), \lambda (s_2:A), make\_prop\ s_1\ s_2\ t): A \xrightarrow{} A \xrightarrow{} Prop.$$

% То есть после подстановки аргументов $s_1, s_2$ и примения правил редукции терм примет следующий вид
% $$(s_1=constr_1 \xrightarrow{} (s_2=constr_{11} \vee ... \vee s_2=constr_{1m})) \wedge ... \wedge (s_1=constr_n \xrightarrow{} (s_2=constr_{n1} \vee ... \vee s_2=constr_{nm})).$$ 
% Этот тип соответствует дугам $(constr_i, constr_{ij}), i=1,...,n, j=i_1,...,i_m.$

% Для задания отношения между состоянием и событиями будем использовать схожий со списком смежности список пар, где первый элемент вершина, а второй список из термов $nat$. Пусть задан терм $l$ типа $list (prod\ A\ (list\ nat))$ описывающий этот список.
% Таким образом, для описания разметки для каждого состояния модели Крипке будем использовать следующий терм
% $$(\lambda (a:nat), \lambda  (b:A), make\_prop\ b\ a\ l): nat \xrightarrow{} A \xrightarrow{} Prop.$$

% То есть после подстановки аргументов $a, b$ и примения правил редукции терм примет следующий вид
% $$(b=constr_1 \xrightarrow{} (a=k_{11} \vee ... \vee a=k_{1m})) \wedge ... \wedge (b=constr_n \xrightarrow{} (a=k_{n1} \vee ... \vee a=k_{nm})).$$ 
% Этот тип соответствует разметке для состояния $constr_i$ переменными $x_{k_{ij}}), i=1,...,n, j=i_1,...,i_m.$


% Множество начальных состояний ограничим одним состоянием $v$, и терм описывающий утверждение, что терм $v$ является начальным состоянием -- это
% $$(\lambda (s:A),\ eq\ s\ v): A \xrightarrow{} Prop.$$

% Терм, соответствующий доказательству тотальности модели, будем брать произвольным.

\subsection{Алгоритмы (тактики)}
Далее полагаем, что в контексте содержится запись $model:=t:sts$, где $t$ - терм типа $sts$, удовлетворяющий ограничениям раздела 4.4.
В разделах 4.5.1-4.5.6 описываются тактики, доказывающие выполнимость формулы конкретного вида (с конкретной внешней операцией), и в них используется центральная вспомогательная тактика $applicator\ n\ f$, доказывающая выполнимость формулы произвольного вида, отвечающей терму $f$ типа $form$, для модели Крипке с $n$ состояниями. 
В разделе 4.5.7 описывается главная тактика $solver$, предназначенная для автоматического доказательства теоремы такого вида, как требуется в формальной постановке задачи в разделе 4.1, при помощи выполнения тактики $applicator$.


\subsubsection{solve\_fV}

Тактика для доказательства выполнимости формулы вида $fV\ n$, где $n$ - терм типа $nat$ (то есть для переменной $x_n$), имеет следующий вид:
\begin{verbatim}
compute;
repeat split;
let pre in
intro pre;
( rewrite init_ in pre; discriminate ) 
+
( repeat ( (left; reflexivity) + (right; reflexivity) + right) )
\end{verbatim}

Эта тактика отвечает следующему алгоритму построения доказательства.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где $g_1$ имеет следующий вид $$((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ (fV\ n)\ \beta)), \theta), init\_/\alpha \in \theta.$$ Параметром алгоритма является имя гипотезы $\alpha$ типа $\beta = v$, где $\alpha \in Name$, $v$ -- терм типа $state\ model$, $\beta$ - терм типа $state\ model$, построенный в контексте $\Gamma$. 
% // а набор ли, или всё-таки только одно?
Тогда выполняются следующие действия:
\begin{enumerate}
    \item[1.] При выполнении $compute$ цель в состоянии доказательства принимает вид
    $$(\beta=constr_1 \xrightarrow{} (n=n_{11} \vee ... \vee n=n_{1m})) \wedge ... \wedge (\beta=constr_k \xrightarrow{} (n=n_{s1} \vee ... \vee n=n_{sm})) $$
    \item[2.] Выполнение $repeat\ split$ разбивает состояние доказательства на $k$ состояния вида
    $$((\Gamma, (\alpha: \beta = v) \vdash (\beta=constr_j) \xrightarrow{} (n=n_{j1} \vee ... \vee n=n_{jm})), \theta).$$
    \item[3.] Выполнение $intro\ pre$ преобразует все состояния к виду 
    $$((\Gamma,  (\alpha: \beta = v) (\gamma: \beta=constr_j) \vdash (n=n_{j1} \vee ... \vee n=n_{jm})), \theta).$$
    \item[4.1.] Если термы $v$ и $constr_j$ не совпадают, то после выполнения $rewrite\ init\_\ in\ pre;\ discriminate$, строится гипотеза о равенстве двух неравных термах, и выполнение $discriminate$ завершает доказательство.
    \item[4.2.] Иначе при помощи $repeat ( (left; reflexivity) + (right; reflexivity) + right)$ перебираются равенства под дизъюнкцией в правой части цели, пока не будет найдено такое, в котором знаком равенства соединены одинаковые числа (термы типа $nat$), и выполнение $reflexivity$ завершает доказательство.
\end{enumerate}

\subsubsection{solve\_fOr} 
Тактика для доказательства выполнимости формулы вида $(fOr\ f_1\ f_2)$ (то есть для формулы вида $f_1 \vee f_2$), где $f_1,f_2$ - подтермы типа $form$, имеет следующий вид:
\begin{verbatim}
compute;
(left; solve [ tac1 init_ ]) + (right; solve [ tac2 init_ ]) 
\end{verbatim}


Эта тактика отвечает следующему алгоритму построения доказательства.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где $g_1$ имеет следующий вид 
$$((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ (fOr\ f_1\ f_2)\ \beta)), \theta), init\_/\alpha \in \theta.$$ Параметрами алгоритма являются имя гипотезы $\alpha$ типа $\beta = v$, где $\alpha \in Name$, $v$ -- терм типа $state\ model$, $\beta$ - терм типа $state\ model$, построенный в контексте $\Gamma$. Положим $tac\_1 = applicator\ n \ f_1, tac\_2 = applicator\ n \ f_2$, которые соответственно доказывают выполнимость формул, отвечающие термам $f_1$ и $f_2$. Параметром этих тактик является имя гипотезы, тип которой имеет вид  $\hat{\beta} = \hat{v}$, где $\hat{v}$ -- терм типа $state\ model$, $\hat{\beta}$ - терм типа $state\ model$, построенный в контексте того, состояния доказательства для которого применяется тактика.

Тогда выполняются следующие действия:
\begin{enumerate}
    \item[1.] При выполнении $compute$ цель в состояниях доказательства принимает вид
    $$(satisfies\ model\ (f_1)\ \beta) \vee (satisfies\ model\ (f_2)\ \beta).$$
    \item[2.] Выполнение $(left;\ solve\ [\ tac1\ init\_\ ])$ преобразует цель в состоянии доказательства к виду $(satisfies\ model\ (f_1)\ \beta)$ и далее применяется тактика $tac1$ с параметром $\alpha$.
    \item[3.1] Если тактика $tac1$ строит успешный вывод, то доказательство завершено.
    \item[3.2] Если тактика $tac1$ не строит успешный вывод, то цель вновь имеет вид $(satisfies\ model\ (f_1)\ \beta) \vee (satisfies\ model\ (f_2)\ \beta)$, и применяется тактика $(right;\ solve\ [\ tac2\ init\_\ ])$, которая преобразует цель в состоянии доказательства к виду $(satisfies\ model\ (f_2)\ \beta)$ и выполняется тактика $tac2$ с параметром $\alpha$. Если тактика $tac2$ строит успешный вывод для правой части дизъюнкции, то доказательство завершено, иначе $\bot$.
\end{enumerate}



\subsubsection{solve\_fAnd}
Тактика для доказательства выполнимости формулы вида $(fAnd\ f_1\ f_2)$ (то есть для формулы вида $f_1 \wedge f_2$), где $f_1,f_2$ - подтермы типа $form$, имеет следующий вид:
\begin{verbatim}
compute;
split; [> solve [ tac1 init_ ] | solve [ tac2 init_] ].
\end{verbatim}

Эта тактика отвечает следующему алгоритму построения доказательства.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где $g_1$ имеет следующий вид 
$$((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ (fAnd\ f_1\ f_2)\ \beta)), \theta), init\_/\alpha \in \theta.$$ Параметрами алгоритма являются имя гипотезы $\alpha$ типа $\beta = v$, где $\alpha \in Name$, $v$ -- терм типа $state\ model$, $\beta$ - терм типа $state\ model$, построенный в контексте $\Gamma$. Положим $tac\_1 = applicator\ n \ f_1, tac\_2 = applicator\ n \ f_2$, которые соответственно доказывают выполнимость формул, отвечающие термам $f_1$ и $f_2$. Параметром этих тактик является имя гипотезы, тип которой имеет вид   $\hat{\beta} = \hat{v}$, где $\hat{v}$ -- терм типа $state\ model$, $\hat{\beta}$ - терм типа $state\ model$, построенный в контексте того, состояния доказательства для которого применяется тактика.

Тогда выполняются следующие действия:
\begin{enumerate}
    \item[1.] При выполнении $compute$ цель в состояниях доказательства принимает вид
    $$(satisfies\ model\ (f_1)\ \beta) \wedge (satisfies\ model\ (f_2)\ \beta).$$
    \item[2.] Применяется тактика $split$, которая <<разбивает>> состояние доказательства на два состояния вида
    $$((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ f_1\ \beta)), \theta)$$
    $$((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ f_2\ \beta)), \theta)$$
    \item[3.] Для первого состояния с параметром $\alpha$ применяется тактика $tac1$, а для второго -- тактика $tac2$. Если обе тактики строят успешный вывод, то доказательство завершено, иначе $\bot$.
\end{enumerate}

\subsubsection{solve\_fAX}

Тактика для доказательства выполнимости формулы вида $(fAX\ f_1)$ (то есть для формулы вида $AX\ f_1$), где $f_1$ - подтерм типа $form$, имеет следующий вид:
\begin{verbatim}
compute;
let next_state in intro next_state;
let trans_to_next_state in intro trans_to_next_state;
compute in trans_to_next_state;
let rec loop conj_hyp init_ :=
  lazymatch type of conj_hyp with
  | and l r => 
    let a in let b in
    destruct conj_hyp as (a & b);
    (apply a in init_) + (apply b in init_) + (loop b)
  | r => 
    idtac
end in
loop trans_to_next_state init_;
  repeat (
    lazymatch type of init_ with
    | or l r =>
      destruct init_ as [init_ | init_]
    | r => 
      idtac
    end
);
solve [ tac1 init_ ]
\end{verbatim}

Эта тактика отвечает следующему алгоритму построения доказательства.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где $g_1$ имеет следующий вид 
$$((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ (fAX\ f_1)\ \beta)), \theta), init\_/\alpha \in \theta.$$ Параметрами алгоритма являются имя гипотезы $\alpha$ типа $\beta = v$, где $\alpha \in Name$, $v$ -- терм типа $state\ model$, $\beta$ - терм типа $state\ model$, построенный в контексте $\Gamma$. Положим $tac\_1 = applicator\ n \ f_1$, который доказывает выполнимость формулы, отвечающей терму $f_1$. Параметром этой тактики является имя гипотезы, тип которой имеет вид $\hat{\beta} = \hat{v}$, где $\hat{v}$ -- терм типа $state\ model$, $\hat{\beta}$ - терм типа $state\ model$, построенный в контексте того, состояния доказательства для которого применяется тактика.

Тогда выполняются следующие действия:
\begin{enumerate}
    % \item[1.] Алгоритм доказывает утверждение для состояний доказательства $g = (g_1, ..., g_n)$, где 
    % $$g_i = ((G_i, (\alpha: \kappa = v) \vdash (satisfies\ model\ (fAX\ f)\ \kappa)), \theta_i), init\_/\alpha \in \theta_i.$$
    \item[1.] При выполнении тактик $compute$ и $intro$ в состоянии доказательства применяются правила редукции к цели и предположения <<переносятся в гипотезы>>. Состояние доказательства на данном этапе имеет следующий вид
    $$((\Gamma, (\alpha: \beta = v), (\gamma: state\ model), (\delta: (trans\  model)\ \beta\ \gamma) $$
    $$\vdash (satisfies\ model\ f\ \gamma)), \theta),$$
    $$next\_state/\gamma, trans\_to\_next\_state/\delta \in \theta.$$
    % Сначала применяются правила редукции к цели (тактика \verb|compute|), затем предположения <<переносятся в гипотезы>> (тактика \verb|intro|). На данном этапе состояние доказательства имеет вид:
    % $$((G_i, (\alpha: \kappa = v) (\gamma: state\ model) (\beta: (trans\  model)\ \kappa\ \gamma) $$
    % $$\vdash (satisfies\ model\ f\ \gamma)), \theta_i),$$
    % $$next\_state/\gamma, trans\_to\_next\_state/\beta \in \theta_i$$
    \item[2.] При выполнении тактики $compute\ in\ trans\_to\_next\_state$ тип гипотезы $\delta$ будет иметь вид
    $$(\beta = constr_1 \xrightarrow{} (\gamma=u_{1_1} \vee ... \vee \gamma=u_{1_m})) \wedge ... \wedge (\beta = constr_n \xrightarrow{} (\gamma=u_{n_1} \vee ... \vee \gamma=u_{n_m}))$$
    \item[3.] Так как по условию в каждой скобке слева от имликации присутствует каждый конструктор, и если $v$ является конструктором $constr_j$, то подвыражение $loop$ будет <<перебирать>> каждую скобку до тех пор пока слева от импликации не появится тип $\beta=contr_j$, и далее выполняется тактика $apply$, которая преобразует тип гипотезы $\alpha$ в $(\gamma=u_{j_1} \vee ... \vee \gamma=u_{j_m}).$
    \item[5.] Далее с помощью тактик $repeat$ и $lazymatch$ состояние доказательства <<разбивается>> на $jm$ состояний вида
    $$((\Gamma, (\alpha: (\gamma=u_{j_s}) (\gamma: state\ model) (\beta: (trans\  model)\ \kappa\ \alpha ) $$
    $$\vdash (satisfies\ model\ f_1\ \gamma)), \theta), s=1,...,j_m.$$
    
    % $$((\Gamma, (\alpha: (\gamma=v_{i1} \vee ... \vee \gamma=v_{im})) (\gamma: state\ model) (\beta: (trans\  model)\ \kappa\ \gamma ) $$
    % $$\vdash (satisfies\ model\ f\ \alpha)), \theta_i),$$ заменяется на $im$ состояний вида
    
    \item[6.] Далее для каждого из $j_m$ состояний выполняется тактика $tac1$ c параметром которой является $\alpha$.
\end{enumerate}



\subsubsection{solve\_fAU}
Рассмотрим вспомогательные тактики.

\textbf{unsplit.} 
Это тактика, которая из двух гипотез создает третью гипотезу, которая является конъюнкцией типов первых двух гипотез.
Параметрами тактики являются $H1,\ H2$-- имена гипотез, типы которых будут использоваться для построения конъюнкции, $H12$ -- имя гипотезы, тип которой будет конъюнкция типов гипотез $H1,\ H2.$
\begin{verbatim}
lazymatch type of H1 with
| t1 => 
  lazymatch type of H2 with 
  | t2 => 
    assert (H12: t1 /\ t2);
    [
      split; [ apply H1 | apply H2 ]
      | 
      idtac
    ]
  end
end
\end{verbatim}

\textbf{next\_state\_gen.} 
Тактика, которая создает гипотезу о состоянии в пути в следующий момент времени при помощи гипотезы о состоянии в пути в настоящий момент времени, имеет следующий вид:

\begin{verbatim}
let is_path_pi_i in
pose proof (is_path_pi i) as is_path_pi_i;
compute in is_path_pi_i;
let rec loop conj_hyp init_ :=
lazymatch type of conj_hyp with
| and l r => 
    let a in let b in
    destruct conj_hyp as (a & b);
    (apply a in init_) + (apply b in init_) + (loop b)
| r => 
    idtac
end
in
loop is_path_pi_j first_state;
repeat (
    lazymatch type of first_state with
    | or l r  =>
        destruct first_state as [first_state | first_state]
    | r => 
        idtac
    end
)
\end{verbatim}

Эта тактика отвечает следующему алгоритму.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где 
$$g_1 = ((\Gamma,(\beta:\Pi (n : nat), (trans\ model) (pi\ n) (pi (S\ n))), $$
$$(pi: nat \xrightarrow{} (state\ model)),(\gamma:pi\ j = v_i)  \vdash A), \theta_i), $$
$$is\_path\_pi/\beta,first\_state/\gamma \in \theta.$$ 
Параметрами тактики являются терм $i$ типа $nat$, гипотеза $is\_path\_pi$ типа $\Pi (n : nat), (trans\ model) (pi\ n) (pi (S\ n))$,  гипотеза $first\_state$ типа $pi\ i = v_i$, где $v_i$ -- это один из конструкторов типа $(state\ model)$, $pi$ имеет тип $nat \xrightarrow{} (state\ model)$. Данная тактика работает только с гипотезами.

Тогда выполняются следующие действия:
\begin{enumerate}
\item[1.] Выполняется тактика $pose\ proof$, которая вносит новую гипотезу $is\_path\_pi\_i$ в контекст, которая имеет тип $(trans\ model) (pi\ i) (pi (S\ i))$. 
\item[2.] При выполнении тактики $compute\ in\ is\_path\_pi\_i$ тип гипотезы принимает вид
$$(pi\ i = constr_1 \xrightarrow{} (pi (S\ i)=u_{11} \vee ... \vee pi (S\ i)=u_{1m})) \wedge ... $$
$$... \wedge (pi\ i = constr_n \xrightarrow{} (pi (S\ i)=u_{n1} \vee ... \vee pi (S\ i)=u_{nm}))$$
\item[3.] Далее схожим образом, как в алгоритме $solve\_fAX$ строятся $s_m$ состояний доказательств для каждого состояния $g_s$
$$((\Gamma_s, (\alpha: pi (S\ i)=u_{sk}) \vdash A, k=1,...,s_m.$$
\end{enumerate}

Определим терм, который интепретируется как усеченная разность между термом $m$ типа $nat$ и термом ($S\ O$) (1). И будем обозначать $m - 1$.
$$(\lambda (m:nat), match\ m\ with\ | S\ n \Rightarrow n | O \Rightarrow O\ end)$$

Далее будем считать построенными следующие термы $t_1, t_2, t_3, t_4$, и по умолчанию будем считать контекст $\hat{\Gamma}$ включенным в каждый.
$$\hat{\Gamma} = $$
$$(usefull:=t_1:\Pi (m:nat), \Pi (n:nat), S\ m \leq n \xrightarrow{} S\ m = n \vee S\ m \leq n - 1,$$
$$usefull2:=t_2:\Pi (m:nat), \Pi (n:nat),  S\ m = S\ n \xrightarrow{} m = n,$$
$$usefull3:=t_3:\Pi (m:nat), \Pi (n:nat),  m \leq n \xrightarrow{} m - 1 \leq n - 1,$$
$$usefull4:=t_4:\Pi (m:nat), \Pi (n:nat),  S\ m = n \xrightarrow{} m = n - 1),$$
где $\leq$ -- это обозначение для индуктивного типа $le$, и $m-1$, $n-1$ -- это усеченная разность c единицей. 

\textbf{proof\_ex\_sat.} 
Тактика, которая для префикса конкретного пути строит вывод для цели вида $p\_until (state\ model) (satisfies\ model\ f_1) (satisfies\ model\ f_2)\ pi,$ где $pi$ типа $nat \xrightarrow{} (state\ model)$, имеет следующий вид:

\begin{verbatim}
compute; 
eexists i; 
[
    let m in intro m; 
    let lt_m in intro lt_m;
    let a in let b in
    destruct seq as (a & b);
    let rec loop i sequence lt_m := 
        lazymatch type of sequence with 
        | and l r =>
            let head in
            let tail in
            destruct sequence as (head & tail);
            apply usefull in lt_m;
            compute in lt_m; 
            destruct lt_m as [lt_m| lt_m]; 
            [
              apply usefull4 in lt_m; compute in lt_m ;rewrite lt_m;
              tac1 head
              |
              (loop (i-1) tail lt_m)
            ] 
        | r => 
            apply usefull in lt_m;
            destruct lt_m as [lt_m| lt_m]; 
            compute in lt_m; 
            [
            apply usefull4 in lt_m; 
            compute in lt_m ;
            rewrite lt_m;
            tac1 sequence
            |
            lia
            ]
        end in
    loop i b lt_m
| 
    let a in
    let b in
    destruct seq as (a&b);
    tac2 a
].
\end{verbatim}

Эта тактика отвечает следующему алгоритму построения доказательства.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где
$$g_1 = ((\Gamma,(pi:nat \xrightarrow{} (state\ model)), (\delta : pi\ i = v_i \wedge ... \wedge pi\ 0 = v_0) $$
$$\vdash p\_until (state\ model) (satisfies\ model\ f_1) (satisfies\ model\ f_2)\ pi), \theta_i),seq/\delta \in \theta.$$
Параметром алгоритма являются терм $i$ типа $nat$, гипотеза $seq$ типа $pi\ i = v_i \wedge ... \wedge pi\ 0 = v_0$.
Положим $tac\_1 = applicator\ n \ f_1, tac\_2 = applicator\ n \ f_2$, которые соответственно доказывают выполнимость формул, отвечающие термам $f_1$ и $f_2$. Параметром этих тактик является имя гипотезы, тип которой имеет вид   $\hat{\beta} = \hat{v}$, где $\hat{v}$ -- терм типа $state\ model$, $\hat{\beta}$ - терм типа $state\ model$, построенный в контексте того, состояния доказательства для которого применяется тактика.

% тактики $tac1,tac2$, которые соответственно доказывают выполнимость формул вида $f_1$ и $f_2$. Параметром тактик $tac1, tac2$ является имя гипотезы типа  $\hat{\beta} = \hat{v}$, где $\hat{v}$ -- терм типа $state\ model$, $\hat{\beta}$ - терм типа $state\ model$, построенный в контексте того, состояния доказательства для которого применяется тактика.

% Она применяется для построения вывода для состояний доказательств, цель которых имеет вид
% $$p\_until (state\ model) (satisfies\ model\ f_1) (satisfies\ model\ f_2) pi,$$ где $pi$ типа $nat \xrightarrow{} (state\ model)$.
% Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где $$g_1 = ((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ (fV\ n)\ \beta)), \theta), init\_/\alpha \in \theta.$$ Параметром алгоритма является имя гипотезы $\alpha$ типа $\beta = v$, где $\alpha \in Name$, $v$ -- терм типа $state\ model$, $\beta$ - терм типа $state\ model$, построенный в контексте $\Gamma$. 

Тогда выполняются следующие действия:
\begin{enumerate}
\item[1.] Выполняется тактика $compute;\ eexists\ i$, и состояние доказательства <<разбивается>> на два состояния, которые соответственно имеют цели
$\Pi (m : nat), m < i \xrightarrow{} satisfies\ model\ f_1\ (pi\ m)$ и $satisfies\ model\ f_2\ (pi\ i)$.
\item[2.1] Рассмотрим первое состояние $$((\Gamma, (\delta : pi\ i = v_i \wedge ... \wedge pi\ 0 = v_0) \vdash \Pi (m : nat), m < i \xrightarrow{} satisfies\ model\ f_1\ (pi\ m)), \theta),$$
$$ seq/\delta \in \theta_i,$$ которое после выполнения тактик $intro$ и $destruct$ принимает вид
$$((\Gamma, (\phi:pi\ i = v_i),(\hat{\delta} : pi\ (i-1) = v_{i-1} \wedge ... \wedge pi\ 0 = v_0), (\kappa : nat) (\gamma: \kappa < i) \vdash $$
$$satisfies\ model\ f_1\ (pi\ \kappa)), \theta), a/\phi,b/\hat{\delta}, m/\kappa, lt\_m/\gamma \in \theta_i$$
\item[2.2] Выполняется тактика $lazymatch$, которая в зависимости от типа $\hat{\delta}$ выполняет соответствующую тактику.
\item[2.2.1] Если тип есть $and$, то гипотеза $(\hat{\delta} : pi\ (i-1) = v_{i-1} \wedge ... \wedge pi\ 0 = v_0)$ снова при помощи тактики $destruct$ <<разбивается>> на две гипотезы $(\hat{\delta_1} : pi\ (i-2) = v_{i-2} \wedge ... \wedge pi\ 0 = v_0)$ и $(\hat{\delta_2} : pi\ (i-1) = v_{i-1})$ в текущем состоянии доказательства.
\item[2.2.2] Далее выполняется тактик $apply$, которая применяет гипотезу $usefull$ к гипотезе $\gamma$, и ее тип принимает вид $ S\ \kappa = i\ \vee \ \kappa < (i - 1)$
\item[2.2.3] Затем тактика $destruct\ lt\_m\ as\ [lt\_m| lt\_m]$ <<разбивает>> состояние доказательства на два состояния с гипотезами типа $S\ \kappa = i$ и $\kappa < (i - 1)$. 
Для первого состояния гипотеза типа $S\ \kappa = i$ при помощи тактики $apply$ и гипотезы $usefull4$ преобразуется в $\kappa = i - 1$, выполняется тактика $tac1$ с параметром $\hat{\delta_2}$ для цели этого состояния $satisfies\ model\ f_1\ (pi\ \kappa)$.
Для второго состояния рекурсивно выполняется тактика $loop$ с гипотезой $\hat{\delta_1}$ в качестве параметра.
\item[2.3] Если тип гипотезы $\hat{\delta}$ не является типом $and$, то тип $\hat{\delta}$ -- это $pi\ 0 = v_0$, а тип гипотезы $\gamma$ -- это $i<1$
\item[2.3.1] Далее выполняется тактика $apply$, которая применяет гипотезу $usefull$ к гипотезе $\gamma$, и ее тип принимает вид $ S\ \kappa = 1\ \vee \ \kappa < 0$.
\item[2.3.2] Затем тактика $destruct\ lt\_m\ as\ [lt\_m| lt\_m]$  <<разбивает>> состояние доказательства на два состояния с гипотезами типа $S\ \kappa = 1$ и $\kappa < 0$. 
Для первого состояния гипотеза типа $S\ \kappa = 1$ при помощи тактики $apply$ и гипотезы $usefull4$ преобразуется в $\kappa = 0$, выполняется тактика $tac1$ с параметром $\hat{\delta_2}$ для цели этого состояния $satisfies\ model\ f_1\ (pi\ \kappa)$.
Для второго состояния выполняется тактика $lia$, так как можно построить невозможное неравенство $\kappa<0$, что позволяет доказать любую цель, включая текущую.
\item[3.1] Рассмотрим второе состояние из пункта 1:
$((\Gamma, (\delta : pi\ i = v_i \wedge ... \wedge pi\ 0 = v_0) \vdash satisfies\ model\ f_2\ (pi\ i)), \theta_i)$
\item[3.2.] Выполняется тактика $destruct$, которая <<разбивает>> гипотезу $\delta$ на гипотезы $(\phi:pi\ i = v_i),(\hat{\delta} : pi\ (i-1) = v_{i-1} \wedge ... \wedge pi\ 0 = v_0)$.
\item[3.3.] Выполняется тактика $tac2$ с параметром $\phi$.
\end{enumerate}


\textbf{loop1.}
Тактика, которая для каждого возможного пути строит конечный префикс и доказывает для него цель вида 
$p\_until (state\ model) (satisfies\ model\ f_1) (satisfies\ model\ f_2)\ pi,$ где $pi$ типа $nat \xrightarrow{} (state\ model)$, имеет следующий вид:

\begin{verbatim}
tryif 
    assert (i=n);[solve [ lia ] | idtac])
then 
    fail
else
    let new in
    assert(new:=last_stop);
    next_state_gen i is_path_pi new;
    let H in
    unsplit new prev_acc H;
    (solve [(proof_ex_sat i prev_acc tac1 tac2)]) 
    + 
    (loop1 (S i) n is_path_pi new H tac1 tac2)
\end{verbatim}

Эта тактика отвечает следующему алгоритму построения доказательства.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где
$$g_1 = ((\Gamma,(pi:nat \xrightarrow{} (state\ model)),(\omega:path (state\ model) (trans\ model) \pi),(\alpha:pi\ i = v_i),$$
$$ (\delta : pi\ i = v_i \wedge ... \wedge pi\ 0 = v_0) \vdash p\_until (state\ model) (satisfies\ model\ f_1) (satisfies\ model\ f_2)\ pi),\theta),$$
$$prev\_acc/\delta,last\_stop/\alpha,is\_path\_pi/\omega \in \theta.$$

Параметром алгоритма являются терм $i$ типа $nat$, терм $n$ типа $nat$ (количество конструкторов индуктивного типа $(state\ model)$), гипотеза $last\_stop$ типа $pi\ i = v_i$, гипотеза $prev\_acc$ типа $pi\ i = v_{i} \wedge ... \wedge pi\ 0 = v_0$ и тактики $tac1,tac2$, которые соответственно доказывают выполнимость формул вида $f_1$ и $f_2$. Параметром тактик $tac1, tac2$ является имя гипотезы типа  $\hat{\beta} = \hat{v}$, где $\hat{v}$ -- терм типа $state\ model$, $\hat{\beta}$ - терм типа $state\ model$, построенный в контексте того, состояния доказательства для которого применяется тактика.


Тогда выполняются следующие действия:
\begin{enumerate}
    \item[1.] Выполняется тактика $tryif$, которая <<проверяет>> равенство $i=n$ так: выполняется тактика $assert$, которая создает новое состояние доказательства с целью $i=n$, а затем выполняется тактика $lia$, которая строит доказательство для этой цели. Если $lia$ строит успешный вывод, то $\bot$.
    \item[2.] Если $lia$ не строит успешный вывод, то выполняется тактика $assert$, которая создает новую гипотезу $\alpha$ и состояние доказательства принимает вид
    $$((\Gamma, (\beta: pi\ i = v_i),(\alpha: pi\ i = v_i),(\delta: pi\ i = v_{i} \wedge ... \wedge pi\ 0 = v_0) \vdash $$
    $$p\_until (state\ model) (satisfies\ model\ f_1) (satisfies\ model\ f_2) pi), \theta),$$
    $$new/\beta \in \theta$$
    \item[3.] Выполняется вспомогательная тактика $next\_state\_gen$ с параметрами $i, \omega, \alpha$, и состояние доказательства <<разбивается>> на $m$ состояний, где тип гипотезы $\alpha$ имеет вид $\alpha:pi\ (S\ i) = \hat{v_j}, j=1,...,m.$
    \item[4.] Выполняется тактика $unsplit$ с параметрами $\alpha, \delta$, которая вносит новую гипотезу $\hat{\delta}$ типа $pi\ (S\ i) = \hat{v_i} \wedge pi\ i = v_{i} \wedge ... \wedge pi\ 0 = v_0$ в контекст.
    \item[5.] Далее выполняется вспомогательная тактика $proof\_ex\_sat$ с параметрами $i, \hat{\delta}, tac1, tac2$. Если тактика $proof\_ex\_sat$ строит успешный вывод для данного <<префикса>> $\hat{\delta}$, то доказательство завершается.
    \item[6.] Если тактика $proof\_ex\_sat$ не строит успешный вывод для данного <<префикса>>, то выполняется тактика $loop1$ с параметрами $(S\ i), n, \omega, \alpha, \hat{\delta}, tac1, tac2$.
\end{enumerate}


\textbf{solve\_fAU.}
Тактика для доказательства выполнимости формулы вида $(fAU\ f_1\ f_2)$ (то есть для формулы вида $AU\ f_1\ f_2$), где $f_1,f_2$ - подтермы типа $form$, имеет следующий вид:

\begin{verbatim}
let pi in
intro pi;
let is_path_pi in
intro is_path_pi;
let first_state in
intro first_state;
rewrite init_l in first_state;
(eexists 0; [> lia | solve [tac2 first_state] ])
+
(loop1 0 n is_path_pi first_state first_state tac1 tac2)
\end{verbatim}
Эта тактика отвечает следующему алгоритму построения доказательства.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где $$g_1 = ((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ (fAU\ f_1\ f_2)\ \beta)), \theta), init\_/\alpha \in \theta.$$ Параметрами алгоритма являются терм $n$ типа $nat$ (количество состояний в модели), имя гипотезы $\alpha$ типа $\beta = v$, где $\alpha \in Name$, $v$ -- терм типа $state\ model$, $\beta$ - терм типа $state\ model$, построенный в контексте $\Gamma$, тактики $tac1,tac2$, которые соответственно доказывают выполнимость формул вида $f_1$ и $f_2$. Параметром тактик $tac1, tac2$ является имя гипотезы типа  $\hat{\beta} = \hat{v}$, где $\hat{v}$ -- терм типа $state\ model$, $\hat{\beta}$ - терм типа $state\ model$, построенный в контексте того, состояния доказательства для которого применяется тактика.
% Параметром алгоритма являются терм $n$ типа $nat$ (количество состояний в модели), имя гипотезы типа $\alpha = v$ и тактики для доказательства подформул.
% И строит доказательство для состояния доказательства следующего вида:
% $$((\Gamma_i, (\beta:\alpha = v) \vdash satisfies\ model\ (fAU\ f_1\ f_2) \alpha), \theta_i)$$

Тогда выполняются следующие действия:
\begin{enumerate}
    \item[1.] Выполняются тактики $intro$ и $rewrite$, и состояние доказательства принимает вид
    $$((\Gamma, (\beta:\alpha = v),(\delta: pi\ 0 = v),$$
    $$ (pi: nat \xrightarrow{} (state\ model)),(\gamma: path (state\ model) (trans\ model)\ pi) $$
    $$ \vdash  p\_until (state\ model) (satisfies\ model\ f_1) (satisfies\ model\ f_2) \pi), \theta_i),$$
    $$is\_path\_pi/\gamma, first\_state/\delta \in \theta.$$
    \item[2.] Выполняется тактика $(eexists\ 0;\ [>\ lia\ |\ solve\ [\ tac2\ first\_state\ ]\ ])$ для доказательства выполнимости формулы для пути состоящего из одного состояния $pi\ 0 = v$. Согласно семантике тактики $eexists$ состояние <<разбивается>> на два состояния. Для первого состояния цель доказывается с помощью противоречия $0<0$ и тактики $lia$. Для второго состояния применяется тактика $tac2$ с параметром $\delta$, если тактика $tac2$ строит успешный вывод, то доказательство завершено.
    \item[3.] Если тактика $tac2$ не построила успешный вывод для пути из одного состояния, то для доказательства цели в состоянии доказательства применяется тактика $loop1$ с аргументами $0, n, \gamma,\delta, \delta, tac1, tac2$.
\end{enumerate}


\subsubsection{Главная тактика applicator}
Главная тактика $applicator$ предназначена для автоматического построения доказательства выполнимости формулы произвольного вида на модели.
% Рассмотрим тактику $applicator$, которая строит тактику, необходимую для доказательства, рассматриваемой формулы. Тактика строит композицию описанных выше тактик согласно формуле. Она принимает на вход терм типа $form$,терм типа $nat$, соответствующий количеству конструкторов индуктивного типа состояний, и возращает тактику для построения вывода.
% Ltac solver n init_l := 
% let rec applicator f  :=
\begin{verbatim}
lazymatch f with
| fAX f_1 => 
    let tac init_ := 
        let tac_1 := (applicator n f_1) in 
        solve_fAX init_ tac_1
    in
    tac
| fOr f_1 f_2 => 
    let tac init_ := 
        let tac_1 := (applicator n f_1) in
        let tac_2 := (applicator n f_2) in 
        solve_fOr init_ tac_1 tac_2
    in 
    tac
| fAnd f_1 f_2 => 
    let tac init_ := 
        let tac_1 := (applicator n f_1) in
        let tac_2 := (applicator n f_2) in 
        solve_fAnd init_ tac_1 tac_2    
    in 
    tac
| fAU f_1 f_2 => 
    let tac init_ := 
        let tac_1 := (applicator n f_1) in
        let tac_2 := (applicator n f_2) in 
        solve_fAU n init_ tac_1 tac_2
    in 
    tac
| fV k => solve_fV
| p => fail
end
\end{verbatim}

Эта тактика отвечает следующему алгоритму построения доказательства.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где $$g_1 = ((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ f\ \beta)), \theta), init\_/\alpha \in \theta,$$ где $f$ терм типа $form$. 
Параметрами алгоритма являются терм типа $nat$ (количество состояний в модели), терм $f$ типа $form$.
Тогда выполняются следующие действия:
\begin{enumerate}
    \item[1.] Терм $f$ формулы, для которой применяется тактика, сопоставляется одним из его конструкторов.
    \item[2.] В зависимости от конструктора $fAX, fOr, fAnd, fAU, fV$ применяется тактика $solve\_fAX, solve\_fOr, solve\_fAnd, solve\_fAU, solve\_fV$, параметризованная именем гипотезы $init\_$. Тактики, которые являются параметрами, для доказательства подформулы $\hat{f}$ формулы $f$ применяются также согласно тактике $applicator\ n\ \hat{f}$.
%     тип которой имеет вид $\beta = v$, где $\beta$ является термом типа $(state\ model)$, построенным в контексте того состояния доказательства для которого применяется та или иная тактика. 
%     , в которой применяется соответствующая конструктору тактика, которой на вход подаются тактики для решения подформул, которые строятся рекурсивным способ для соответствующий подформул.

% которой" вложено в "которой", плохо читается.
% и переформулируйте понятнее.
% имя гипотезы init_ - это, надо полагать, параметр, и его значение - это та тактика, которую, собственно, и нужно вызвать?

% а нельзя ли избавиться от этих let, если во вспомогательных тактиках писать не tac_1 tac_2, а сразу applicator?
% и тогда переформулировать всё сразу как "в зависимости от вида формулы к ней применяется одна из вспомогательных тактик <перечислить их названия>, доказывающих выполнимость формулы соответствующего вида".

    
    \item[3.] Таким образом тактика $applicator$, строит тактику согласно структуре формулы (как одна формула вложена в другую)
\end{enumerate}

Тактика $applicator$ может применяться не для всех термов типа $form$, а только для термов, которые построены с помощью конструкторов $fAX, fOr, fAnd, fAU, fV$. Построение соответствующих вспомогательных тактик для доказательства формул оказалось достаточно трудозатратныйм, поэтому на данный момент вспомогательные тактики для доказательства формул другого вида не построены.

% или где-то тут, или у главной тактики, или в начале раздела надо бы всё-таки пояснить, что здесь неспроста перечислены не все операции - что хотелось бы все, но на данный момент это не получилось, и получить результат для формул, построенных над операциями, упомянутыми в центральной вспомогательной тактике, уже оказалось достаточно непростой задачей


\subsubsection{Главная тактика}
Главная тактика $solver$, предназначенная для автоматического доказательства суждения о типе, записанного в формальной постановке задачи в разделе 4.1, устроена следующим образом.

\begin{verbatim}
lazymatch goal with
| satisfies model f st => 
    let tac := applicator n f in 
    tac init_l
| p => fail
end.
\end{verbatim}
Эта тактика отвечает следующему алгоритму построения доказательства.
Пусть на вход алгоритму подан набор состояний доказательства $g = (g_1)$, где $$g_1 = ((\Gamma, (\alpha: \beta = v) \vdash (satisfies\ model\ f\ \beta)), \theta), init\_/\alpha \in \theta.$$
Параметром алгоритма является терм $n$ типа $nat$ (количество конструкторов типа $state\ model$) и имя гипотезы $\alpha$ типа $\beta = v$.

Тогда выполняются следующие действия:
\begin{enumerate}
    \item[1.] Текущая цель в состоянии доказательства сопоставляется с термом $satisfies$ и его аргументами.
    \item[2.] Если сопоставление успешно, то есть в доказываемом терме действительно утверждается выполнимость некоторой формулы на некоторой модели, то вызывается центральная вспомогательная тактика, строящая доказательство для формулы и модели, извлечённых при сопоставлении.
    \item[3.] Иначе доказательство завершается неуспехом (ошибкой).
    % \item[2.] Одним из аргументов этого терма является формула-терм $f$, для которой строится проверка модели.
    % \item[3.] Далее $f$ используется как аргумент $applicator$ для построения тактики для построения вывода.
\end{enumerate}


\subsection{Корректность главной тактики}
% Корректность (более подробно, на дурака объяснить)
% Как устроен Кок? Почему ему можно доверять?
% Есть Ядро(который основан на надежной теории)+Надстройки (они сертифицировано самим ядром)
% (Если используем Ядро, Инструменты, Сертификация)


% Моё предложение, начиная с двоеточия (попробуйте посмотреть в написанное, посмотреть сюда и подумать, не хотите ли что поправить):

Интерактивное средство \textit{Coq} доказательства теорем можно условно разделить на две состовляющие: небольшое ядро, предоставляющее средства проверки типа заданного терма, и обширный спектр модулей, надстраивающихся над этим ядром и предоставляющих конкретные индуктивные типы, средства работы с этими типами, тактики и т.п.

Ядро имеет небольшой размер и относительно просто реализует относительно небольшой набор понятий, и отладке ядра уделялось много внимания в течение нескольких десятилетий.
Поэтому считается, что наличие ошибок в ядре очень маловероятно, и принято доверять результатам проверки ядра по крайней мере настолько же, как если бы соответствующие выкладки были оформлены общепринятыми способами на естественном языке квалифицированным математиком в научной публикации, и даже больше\cite{CoqCorrect}.

Согласно изоморфизму Карри--Говарда (см., раздел 2.2.5), доказательство утверждения \textit{A} в средстве \textit{Coq} представляет собой терм, имеющий тип \textit{A}, и построение этого доказательства представляет собой вывод суждения о типе с подходящим термом-доказательством средствами ядра\cite{CHC}.
Поэтому все доказательства в \textit{Coq} принято считать корректными - настолько же, насколько и ядро \textit{Coq}, а значит, просто корректными.
В частности, это означает, что и тактика построения доказательства выполнимости формулы \textit{CTL} на модели Крипке, предложенная в разделе 4.5.7, считается корректной: если доказательство, построенное при помощи средств \textit{Coq} (базовых тактик и языка \textit{Ltac}) успешно завершено, то оно считается корректным.
Остаётся только вопрос, для каких именно теорем доказательство будет успешно построено - но это вопрос полноты, обсуждающийся далее в разделе 4.7.
% // и понапихайте в меру своих знаний ссылки везде, где говорится про что-то неочевидное - доверие к ядру, корректность ядра, что все построения проходят через ядро, ... - по необходимости поправив все эти факты в меру своего знания и моего незнания




% Интерактивное средство $Coq$ доказательства теорем можно условно разделить на две состовляющие: ядро для проверки термов и инструменты для описания термов над этим ядром.

% Ядро предназначено определения типа, который имеет конкретный терм. Ядро устроено относительно простым образом, так чтобы минимизировать вероятность ошибки, а исчисление конструкций ($CIC$), которое является теоретической основой ядра, надежно и непротиворечиво \cite{Coquand}.

% Одним из инструментов для описания термов являются тактики. Тактики —  это небольшие программы, которые из построенного вывода строят терм. 
% И тактика строит успешный вывод, если терм соответсвует тому типу, который требуется (это проверяется самим ядром), поэтому если тактика завершила успешно работу, то терм корректен.

% \textit{Coq} широко используется для проверки уже доказанных теорем в математике \cite{mathcomp}.
% И проверяются теоремы так: если утверждение соответствующее исходной теореме можно доказать в \textit{Coq}, то оно верно. Также можно сказать об утверждении о выполнимости формулы на модели: если алгоритм на тактиках построил успешный вывод, то верно утверждение о том, что формула выполняется на модели. 

% Таким образом, алгоритмы на тактиках, описанные в разделе 4.5, обладают свойством корректности.


\subsection{Полнота главной тактики}
% 1. Где-то в этом разделе можно ещё раз повторить, ткнув в пункт 2, что увы, в формулировке теоремы не произвольные формулы, а только фрагмент с упомянутыми операциями, но и для такого фрагмента задача оказалась непростой.
% 2. Теорема.
% 3. Если это latex, то формулировку теоремы сделайте внутри
\begin{theorem}
Пусть выполнены следующие условия:
\begin{enumerate}
    \item[1.] model - произвольный терм типа \textit{sts}, соответствующий модели Крипке M согласно изложенному в разделе 2.1 и построенный согласно ограничениям раздела 4.4.
    \item[2.] f - произвольный терм типа form, не содержащий конструкторы fF, fImp, fAR (то есть содержащий только конструкторы fV, fAnd, fOr, fAX, fAU) и соответствующий формуле CTL $\varphi$ согласно изложенному в разделе 2.1.
    \item[3.] $M \models \varphi$
    \item[4.] $g = (g_1)$ - набор состояний доказательства, имеющий следующий вид 
    $$g_1 = ((\Gamma_{MC}, (\alpha: \beta=t) \vdash satisifies\ model\ f\ \beta), \theta_i),$$ где t - конструктор, 
    отвечающий начальному состоянию M, $\Gamma_{MC}$ -- контекст описанный в разделе 4.1.
    \item[5.] n - терм типа nat, отвечающий числу конструкторов типа state model. 
\end{enumerate}

Тогда тактика solver с параметрами n и $\alpha$ строит успешный вывод для набора g.

% и доказательство - внутри
% \begin{proof}
% \end{proof}
% Для окружения proof м.б. понадобится какой-нибудь пакет (если выдаст ошибку, что не знает, что такое proof, то погуглите).
% Если окружения theorem по умолчанию нет (выдаст ошибку, что не знает, что такое theorem), то в шапку добавьте
% \newtheorem*{theorem}{Теорема}


% Пусть выполнено следующие условия:
% \begin{enumerate}
%     \item[1.] Терм $model$ типа $sts$, соответствующий модели Крипке, построен согласно ограничениям из раздела 4.4.
%     \item[2.] Терм $f$ типа $form$ построен с помощью конструкторов $fV, fAX, fAnd, fOr, fAU$.
%     \item[3.] Состояние доказательства $g = (g_1,...,g_l)$ имеет следующий вид:
%     $$g_i = ((\Gamma_i, (\alpha: \beta=t) \vdash satisifies\ model\ f\ \beta), \theta_i),$$
%     где $t$ -- один из конструкторов типа $state\ model.$
% \end{enumerate}

% Тогда если для цели в текущем состоянии доказательства можно построить успешный вывод, то
% тактика $solver$ с аргументами $n$ и $\alpha$ строит успешный вывод для текущего состояния доказательства, где $n$ терм типа $nat$, соответствующий числу конструкторов типа $state\  model$.


\begin{proof} \textbf{Доказательство.}
Доказательство будем проводить с помощью индукции по формуле $f$.

\textbf{База индукции:} $f = fV\ k$, где $k$ -- терм типа $nat$. Это означает, что согласно построенным ограничениям после применения правил редукции цель состояния g будет иметь следующий вид 
$$(t=constr_1 \xrightarrow{} A_1) \wedge ... \wedge (t=constr_j \xrightarrow{} (k=j_{1} \vee ...\vee k=k \vee ...\vee k=j_{m}) \wedge ... \wedge(t=constr_n \xrightarrow{} A_n).$$

% при выполнении .. выбирается и выполняется .. . Так как M \models \varphi, то <чего хорошего содержится в этой цели>, а значит, по устройству тактики .., она успешно завершит доказательство этой цели.

% В таком случае, тактика $applicator$ сопоставит терм $fV\ k$ с тактикой $solve\_fV$. 
При выполнении тактики $applicator\ (fV\ k)$ выбирается и выполняется тактика $solve\_fV$ с параметром $\alpha$. Так как $M \models \varphi$, то для каждой скобки: если $t$ совпадает с $constr_j$, то справа от импликации в дизъюнкции есть тип $k=k$, а значит, по устройству тактики $( repeat ( (left; reflexivity) + (right; reflexivity) + right) )$, она успешно завершит доказательство этой цели, иначе слева от ипликации можно построить равенство $t=constr_j$ двух разных конструкторов, а значит, по устройству тактики $( rewrite init_ in pre; discriminate )$, она успешно завершит доказательство этой цели.

% Тактика $solve\_fV$ с гипотезой $\alpha$ в качестве аргумента построит успешный вывод, так как для каждой скобки: если $t$ совпадает с $constr_j$, то цель доказывается с помощью $reflexivity$, так как среди дизъюнкций есть тип $k=k$, иначе доказывается с помощью противоречия $t=constr_j, j \neq i$ и тактики $discriminate$.

\textbf{Индуктивный переход.}

% Пусть формула $f$ выполняется на модели и свойством полноты обладают тактики для доказательства подформул $f$. 
Согласно условию, $f$ имеет вид $(AX\ f_1),\ (f_1 \vee f_2),(f_1 \wedge f_2)$ или $(AU\ f_1 \ f_2).$ 
Рассмотрим каждый из этих случаев.

\textbf{Случай 1.} $f=fAX\ f_1.$ Это означает, что согласно построенным ограничениям состояния доказательства будут иметь следующий вид 
$$((\Gamma_i, (\alpha: \beta=t) \vdash satisifies\ model\ (fAX\ f_1)\ \beta), \theta_i).$$


При выполнении тактики $applicator\ n\ (fAX\ f_1)$ выбирается и выполняется тактика $solve\_fAX$ с параметром $\alpha$.
Так как $M \models \varphi$, то
согласно построению тактики $solve\_fAX$ (см. пункт 5 пояснений в разделе 4.5.4) преобразует состояние доказательство в состояние вида
$$((\Gamma_i, (\alpha: \gamma=\hat{v_{i}}), (\gamma: state\ model), (\zeta: (trans\  model)\ \beta\ \gamma ) $$
    $$\vdash (satisfies\ model\ f_1\ \gamma)), \theta_i).$$
А по индуктивному предположению, тактика $applicator\ n\ f_1$ строит успешный вывод для целей вида $$g_i = ((\Gamma_i, (\hat{\alpha}: \gamma=\hat{t}) \vdash satisifies\ model\ f_1\ \gamma), \theta_i).$$

Таким образом, $applicator\ n\ f_1$ с аргументом ${\alpha}$ по предположению индукции построит успешный вывод для состояния доказательства, которое было получено применением тактики $solve\_fAX$.


\textbf{Случай 2.} $f=(fOr\ f_1\ f_2).$
Это означает, что согласно построенным ограничениям состояния доказательства будут иметь следующий вид 
$$((\Gamma_i, (\alpha: \beta=t) \vdash satisifies\ model\ (fOr\ f_1\ f_2)\ \beta), \theta_i).$$

При выполнении тактики $applicator\ n\ (fOr\ f_1\ f_2)$ выбирается и выполняется тактика $solve\_fOr$ с параметром $\alpha$.
Так как $M \models \varphi$, то
согласно построению тактики $solve\_fOr$ (см. пункт 2 пояснений в разделе 4.5.2) преобразует состояние доказательство в состояние вида
$$((\Gamma_i, (\alpha: \beta=t) \vdash satisifies\ model\ f_1\ \beta), \theta_i).$$
А по индуктивному предположению, тактика $applicator\ n\ f_1$
строит успешный вывод для состояния доказательства вида
$$g_i = ((\Gamma_i, (\hat{\alpha}: \gamma=\hat{t}) \vdash satisifies\ model\ f_1\ \gamma), \theta_i).$$


И если формула, отвечающая терму $f_1$, выполняется на модели, то тактика $applicator\ n\ f_1$ с аргументом ${\alpha}$ по предположению индукции построит успешный вывод.
% Иначе если тактика $tac1$ не построила успешный вывод, то согласно пункту 2 алгоритма $solve\_fOr$ тактика
Иначе формула, отвечающая $f_1$, не выполняется на модели, и по построению тактики $solve\_fOr$ (см. пункт 2 пояснений в разделе 4.5.2) эта тактика преобразует состояние в состояние вида
$$((\Gamma_i, (\alpha: \beta=t) \vdash satisifies\ model\ f_2\ \beta), \theta_i).$$ 

А по индуктивному предположению тактика $applicator\ n\ f_2$
строит успешный вывод для состояния доказательства
$$g_i = ((\Gamma_i, (\hat{\alpha}: \gamma=\hat{t}) \vdash satisifies\ model\ f_2\ \gamma), \theta_i).$$

Таким образом, тактика $applicator\ n\ f_2$ с параметром $\alpha$ строит успешный вывод, и соответственно тактика $solve\_fOr$ тоже.


\textbf{Случай 3.} $f=(fAnd\ f_1\ f_2).$
Это означает, что согласно построенным ограничениям состояния доказательства будут иметь следующий вид 
$$((\Gamma_i, (\alpha: \beta=t) \vdash satisifies\ model\ (fAnd\ f_1\ f_2)\ \beta), \theta_i).$$


При выполнении тактики $applicator\ n\ (fAnd\ f_1\ f_2)$ выбирается и выполняется тактика $solve\_fAnd$ с параметром $\alpha$.
Так как $M \models \varphi$, то
согласно построению тактики $solve\_fAnd$ (см. пункт 2 пояснений в разделе 4.5.3) преобразует состояние доказательство в состояния вида
$$((\Gamma_i, (\alpha: \beta=t) \vdash satisifies\ model\ f_1\ \beta), \theta_i),$$
$$((\Gamma_i, (\alpha: \beta=t) \vdash satisifies\ model\ f_2\ \beta), \theta_i).$$


А по индуктивному предположению, тактики $applicator\ n\ f_1$ и $applicator\ n\ f_2$ строят успешный вывод соответственно для состояний доказательства вида
$$g_i = ((\Gamma_i, (\hat{\alpha}: \gamma=\hat{t}) \vdash satisifies\ model\ f_1\ \gamma), \theta_i),$$
$$g_i = ((\Gamma_i, (\hat{\alpha}: \gamma=\hat{t}) \vdash satisifies\ model\ f_2\ \gamma), \theta_i).$$

Таким образом, по предположению индукции о том, что тактики $applicator\ n\ f_1$ и $applicator\ n\ f_2$ строят успешный вывод для подформул, отвечающих соответственно термам $f_1$ и $f_2$, тактика $solve\_fAnd$ строит успешный вывод.

\textbf{Случай 4.} $f=(fAU\ f_1\ f_2).$
Это означает, что согласно построенным ограничениям состояния доказательства будут иметь следующий вид 
$$((\Gamma_i, (\alpha: \beta=t) \vdash satisifies\ model\ (fAU\ f_1\ f_2) \ \beta), \theta_i).$$

При выполнении тактики $applicator\ n\ (fAU\ f_1\ f_2)$ выбирается и выполняется тактика $solve\_fAU$ с параметром $\alpha$.

А по индуктивному предположению, тактики $applicator\ n\ f_1$ и $applicator\ n\ f_2$ строят успешный вывод соответственно для состояний доказательства вида
$$g_i = ((\Gamma_i, (\hat{\alpha}: \gamma=\hat{t}) \vdash satisifies\ model\ f_1\ \gamma), \theta_i),$$
$$g_i = ((\Gamma_i, (\hat{\alpha}: \gamma=\hat{t}) \vdash satisifies\ model\ f_2\ \gamma), \theta_i).$$


Так как $M \models \varphi$, то
согласно построению тактики $solve\_fAU$ (см. пункт 1 пояснений в разделе 4.5.5) преобразует состояние доказательство в состояния вида
$$((\Gamma_i, (\beta: pi\ 0 = t), \vdash $$
    $$p\_until (state\ model) (satisfies\ model\ f_1) (satisfies\ model\ f_2) pi), \theta_i)$$

Рассмотрим путь, состоящий из одного состояния $pi\ 0 = t$. И согласно построению тактики $solve\_fAU$ (см. пункт 2 пояснений в разделе 4.5.5) состояние доказательства преобразуется в состояния доказательства с целями вида:
$$\Pi (m : nat), m < 0 \xrightarrow{}\ satisfies\ model\ f_1\ (pi\ m),$$
$$satisfies\ model\ f_2\ (pi\ 0)$$

Для первого состояния вывод строится с помощью противоречия $m<0$ и тактики $lia$. Для второго состояния по предположению индукции вывод строит тактика $applicator\ n\ f_2$ с гипотезой $\beta$ в качестве параметра.

Если для этого пути тактики не строят успешный вывод. Рассмотрим путь, состоящий из двух состояний $pi\ 0 = t, pi\ 1 = t_1$.
Выполняется тактика $loop1$, и согласно построению тактики $loop1$ (см. пункт 4 пояснений в разделе $loop1$)
состояние доказательства будет иметь вид
$$((\Gamma_i, (\beta: pi\ 1 = t_1),(\gamma: pi\ 1 = t_1  \wedge pi\ 0 = t) \vdash $$
    $$p\_until (state\ model) (satisfies\ model\ f_1) (satisfies\ model\ f_2) pi), \theta_i).$$

И выполняется тактика $proof\_ex\_sat$,
согласно построению тактики $proof\_ex\_sat$ (см. пункт 2.1 и 3.1 пояснений в разделе $proof\_ex\_sat$)
цели состояний доказательства будут иметь следующий вид
$$\Pi (m : nat), m < 1 \xrightarrow{}\ satisfies\ model\ f_1\ (pi\ m),$$
$$satisfies\ model\ f_2\ (pi\ 1)$$

Для первого состояния применяется подвыражение $loop$ (см. пункт 2.2.3 пояснений в разделе $proof\_ex\_sat$), используя тактику $applicator\ n\ f_1$, которая строит успешный вывод по предположению индукции. Для второго состояния по предположению индукции вывод строит тактика $applicator\ n\ f_2$ с гипотезой $\beta$ в качестве аргумента.

Если для этого пути тактики не строят успешный вывод, то рассматривается путь с еще одним состоянием до тех пор, пока не построится успешный вывод.

Тактика $loop1$ действует до тех пор пока в состояний в пути не становится равным $n$ (числу состояний/конструкторов в модели Крипке). Эта тактика использует тот факт, что для проверки выполнимости формулы $AU$ на модели Крипке достаточно проверить все пути, которые имеют количество состояний меньше либо равно чем количество состояний в модели Крипке\cite{Karpov}.

Таким образом, по предположению индукции о том, что тактики $applicator\ n\ f_1$ и $applicator\ n\ f_2$ строят успешный вывод для подформул, отвечающих соответственно термам $f_1$ и $f_2$, тактика $solve\_fAU$ строит успешный вывод.

% про AU неплохо бы, наверное, переформулировать, разделив рассуждение о произвольном пути (A) и о том, что для него верно (U). не уверен, есть ли прямо такая теорема, но imho конкретно по этому факту можно сослаться туда, где есть алгоритм верификации для CTL с обоснование корректности - так или иначе, явно или прикрыто в этом обосновании должно мелькать рассуждение о том, что можно смотреть на пути не очень длинные, ибо на нём корректность со сложностью и основываются.



% По теореме \textbf{кого-то}, если формула $AU\ f_1\ f_2$ выполняется на модели, то существует номер $m,\ m<n$ в произовольном пути, на котором в его $m$-ом состоянии выполняется $f_2$, а в состояниях, соответствующих номерам $i,\ i<m$ выполняется формула $f_1$.

% Тактика $solve\_fAU$ существенно использует теорему \textbf{кого-то}. Она строит гипотезы тип которых имеет вид $ pi\ i = v_i \wedge ... \wedge pi\ 0 = v_0$ и применяет тактику $proof\_ex\_sat$ с тактиками $tac1,tac2$ в качестве аргумента, где $tac2$ доказывает выполнимость с гипотезой типа $pi\ i = v_i$, а тактика $tac2$ с гипотезой типа $pi\ j= v_j, j < i$. Если тактики не строят успешный вывод, то рассматривается гипотеза $ pi\ (S\ i) = v_i \wedge ... \wedge pi\ 0 = v_0$, и действия повторяются. По теореме \textbf{кого-то} тактика обязательно построит гипотезу, для которой можно построить успешный вывод.
\end{proof}
\end{theorem}


\section{Полученные результаты}
В магистерской диссертации получены следующие результаты:
\begin{enumerate}
    \item[1.] Формально поставлена задача проверки модели в терминах исчисления индуктивных конструкций (раздел 4.1).
    \item[2.] Предложены формальные синтаксис и семантика фрагмента языка \textit{Ltac} и базовых тактик, которые используются для решения задачи проверки модели в терминах исчисления индуктивных конструкций (разделы 4.2, 4.3).
    \item[3.] Разработан алгоритм (раздел 4.5.7), записанный в терминах формализованных элементов языка \textit{Ltac}, который доказывает выполнимость формулы \textit{CTL}, построенной над операциями $p,\ AX,\ \vee,\ \wedge,\ AU$, на модели Крипке, представленной согласно разделу 4.4.
    \item[4.] Обоснована полнота предложенного алгоритма (раздел 4.7) и отмечено, что обоснование корректности не требуется (раздел 4.6).
\end{enumerate}


\newpage
\addcontentsline{toc}{section}{Список литературы}%
  \begin{thebibliography}{99}%
  %   \bibitem{jour} Петров~П.\,П., Сидоров~С.\,С. Статья в журнале~// Название журнала.~--- 2000. Т.~3, №~1.~--- с.~55--66.
  %   \bibitem{conf} Петров~П.\,П. Статья в сборнике~// Сборник трудов той самой конференции.~--- Казань:~Казанский федеральный университет, 2000.~--- с.~66--70.
  %   \bibitem{book} Петров~П.\,П. Название книги.~--- М:~Макс Пресс, 2000.~--- 95~с.
  \bibitem{Clark} Кларк Э.М., Грамберг О., Пелед Д. Верификация моделей программ: Model Checking. – М.: МЦНМО, 2002.
    
    \bibitem{CompCert} Blazy S., Leroy X. Formal verification of a memory model for C-like imperative languages. In International Conference on Formal Engineering Methods (ICFEM 2005), Springer, Vol. 3785, 2005, p. 280-299.
    
    \bibitem{SoftwareFoundations6} Pierce B. C. Software Foundations Volume 5: Verifiable C. Electronic textbook. [Электронный ресурс]. - Электрон. дан. - URL: \URL{https://softwarefoundations.cis.upenn.edu/vc-current/index.html}. (дата обращения 14.02.2023)
    
    \bibitem{mathcomp}The Mathematical Components Library [Электронный ресурс]. - Электрон. дан. - URL: \URL{https://github.com/math-comp/math-comp}. (дата обращения 21.05.2022)

    \bibitem{LtacRef}  Logic for Programming and Automated Reasoning. LPAR 2000. Lecture Notes in Artificial Intelligence, vol 1955. Springer, Berlin, Heidelberg. P. 85-95.
    % Delahaye D. A Tactic Language for the System Coq. Logic Programming and Automated Reasoning, 2000.

    \bibitem{2007} Tsai, MH., Wang, BY. Formalization of CTL* in Calculus of Inductive Constructions. Secure Software and Related Issues. ASIAN 2006. Lecture Notes in Computer Science, Springer, Vol. 4435,  2007, p. 316-330.

    \bibitem{thesis_article} Doczkal, C., Smolka, G. (2016). Completeness and Decidability Results for CTL in Constructive Type Theory. Journal of Automated Reasoning, Vol. 56, 2016, p. 343–365. 
    \bibitem{thesis} Doczkal C. A Machine-Checked Constructive Metatheory of Computation Tree Logic. PhD Thesis. Saarland University, 2015.

    \bibitem{2003} Coupet-Grimal S. An Axiomatization of Linear Temporal Logic in the Calculus of Inductive Constructions. Journal of Logic and Computation, Vol. 13, 2003, p. 801–813.
    
    \bibitem{micromega} Besson F. Fast Reflexive Arithmetic Tactics the Linear Case and Beyond. Types for Proofs and Programs, Springer, Berlin, Heidelberg, 2007, p. 48-62.

    \bibitem{Ltac} Ltac. Documentation. [Электронный ресурс]. - Электрон. дан. - URL: \URL{https://coq.inria.fr/refman/proof-engine/ltac.html}. (дата обращения 14.12.2022)

    \bibitem{Karpov} Карпов~Ю.\,Г. MODEL CHECKING. Верификация параллельных и распределенных программных систем. -- СПб.: ~БХВ-Петербург, 2010. 

    \bibitem{CIC} Paulin-Mohring C. Introduction to the Calculus of Inductive Constructions. All about Proofs, Proofs for All, Vol. 55, College Publications, 2015, Studies
in Logic (Mathematical logic and foundations).
    % -- 560 c.

    \bibitem{Coquand} Coquand T., Huet G. The calculus of constructions.
    Information and computation, Vol. 76, 1988, p. 95-120.
    
    \bibitem{CHC} Howard W.A. The formulae-as-types notion of constructions. To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, Academic Press, 1980, p. 479–490.

    \bibitem{CHCCOQ} Coq. Documentation. [Электронный ресурс]. - Электрон. дан. - URL: \URL{https://coq.inria.fr/refman/proofs/writing-proofs/proof-mode.html}. (дата обращения 14.02.2023) 
    
    % \bibitem{SoftwareFoundations1} Pierce B. C. Software Foundations. Volume 1: Logical Foundations. Electronic textbook. ver. 6.1. 2021.
    
    % \bibitem{SoftwareFoundations6} Pierce B. C. Software Foundations Volume 5: Verifiable C. Electronic textbook. ver. 6.5. 2021.
    

    % \bibitem{CoqArt} Bertot Y., Castéran P. Interactive Theorem Proving and Program Development: Coq’Art: The Calculus of Inductive Constructions. Springer, 2004.

     
    
    
    
    
    
    % \bibitem{2003github} Linear temporal logic. Repository. [Электронный ресурс]. - Электрон. дан. - URL: \URL{https://github.com/coq-contribs/ltl}. (дата обращения 21.05.2022)

    

    
    
    \bibitem{lib} Coq. Documentation. [Электронный ресурс]. - Электрон. дан. - URL: \URL{https://coq.inria.fr}. (дата обращения 10.02.2023)

    \bibitem{thesisgithub} Completeness and Decidability of Modal Logic Calculi [Электронный ресурс]. - Электрон. дан. - URL: \URL{https://github.com/coq-community/comp-dec-modal}. (дата обращения 21.05.2022)

    \bibitem{LtacFull} Jedynak W. Operational Semantics of Ltac. Master Thesis. Uniwersytet Wroclawski, 2013.
    
    \bibitem{CoqCorrect} Sozeau M., Boulier S., Forster Y., Tabareau N., Winterhalter T. Coq Coq Correct! Verification of Type Checking and Erasure for Coq, in Coq. Proc. ACM Program. Lang., Vol. 4, 2020, Article 8, p. 1-28.
    % Matthieu Sozeau, Simon Boulier, Yannick Forster, Nicolas Tabareau, and Théo Winterhalter. 2019. Coq Coq correct! verification of type checking and erasure for Coq, in Coq. Proc. ACM Program. Lang. 4, POPL, Article 8 (January 2020), 28 pages. https://doi.org/10.1145/3371076
  \end{thebibliography}




  
\end{document}
